<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>兔子的个人博客 - Hexo Blog</title>
  
  <subtitle>非学无以广才，非志无以成学</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://proudrabbit.gitee.io/"/>
  <updated>2021-01-08T03:22:41.790Z</updated>
  <id>https://proudrabbit.gitee.io/</id>
  
  <author>
    <name>路痴的兔子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（十）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89.html</id>
    <published>2021-01-08T03:21:09.000Z</published>
    <updated>2021-01-08T03:22:41.790Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="一、Linux阻塞和非阻塞IO"><a href="#一、Linux阻塞和非阻塞IO" class="headerlink" title="一、Linux阻塞和非阻塞IO"></a>一、Linux阻塞和非阻塞IO</h2><h3 id="1-1-阻塞和非阻塞简介"><a href="#1-1-阻塞和非阻塞简介" class="headerlink" title="1.1 阻塞和非阻塞简介"></a>1.1 阻塞和非阻塞简介</h3><p>这里的 <code>IO</code> 指的是 <code>Input/Output</code>，也就是输入/输出，是应用程序对驱动设备的输入/输出操作。当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式 <code>IO</code> 就会将应用程序对应的线程挂起，直到设备资源可以获取为止。对于非阻塞 <code>IO</code>，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃。</p><a id="more"></a><ul><li><p>阻塞式<code>IO</code>：</p><blockquote><p>当资源不可用时，应用程序就会挂起。当资源可用的时候，唤醒任务。应用程序使用<code>open</code>打开驱动文件，默认是阻塞方式打开。</p><p>阻塞式<code>IO</code>访问示意图：</p><p><img src="https://i.loli.net/2020/12/23/Hb3IhCd95umSLcD.png" alt="阻塞式IO" title="阻塞式IO"></p></blockquote></li><li><p>非阻塞式<code>IO</code>：</p><blockquote><p>当资源不可用的时候，应用程序轮询查看，或放弃。会有超时处理。应用程序如果想在使用<code>open</code>打开驱动文件时使用非阻塞的方式打开，需要使用<code>O_NONBLOCK</code>。</p><p>非阻塞式<code>IO</code>访问示意图：</p><p><img src="https://i.loli.net/2020/12/23/TPzJBZXh7eqCg6V.png" alt="非阻塞式IO" title="非阻塞式IO"></p></blockquote></li></ul><h3 id="1-2-等待队列（阻塞访问）"><a href="#1-2-等待队列（阻塞访问）" class="headerlink" title="1.2 等待队列（阻塞访问）"></a>1.2 等待队列（阻塞访问）</h3><ol><li><p>等待队列头</p><p>阻塞访问最大的好处就是当设备文件不可操作的时候进程可以进入休眠态，这样可以将<code>CPU</code> 资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。 <code>Linux</code>内核提供了等待队列(<code>wait queue</code>)来实现阻塞进程的唤醒工作，如果我们要在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体<code>wait_queue_head_t</code> 表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue_head</span> <span class="title">wait_queue_head_t</span>;</span></span><br></pre></td></tr></table></figure><p>定义好等待队列头以后需要初始化，使用 <code>init_waitqueue_head</code> 函数初始化等待队列头，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param q 等待队列头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_waitqueue_head</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span></span><br></pre></td></tr></table></figure><p>也可以使用宏 <code>DECLARE_WAIT_QUEUE_HEAD</code> 来一次性完成等待队列头的定义和初始化。</p></li><li><p>等待队列项</p><p>等待队列头就是一个等待队列的头部，每个访问设备的进程都是一个队列项，当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面。结构体 <code>wait_queue_t</code> 表示等待队列项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">wait_queue_func_t</span> func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">task_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">wait_queue</span> <span class="title">wait_queue_t</span>;</span></span><br></pre></td></tr></table></figure><p>同样可以使用宏 <code>DECLARE_WAITQUEUE</code> 定义并初始化一个等待队列项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param name 等待队列项的名字</span></span><br><span class="line"><span class="comment"> * @param tsk 表示该等待队列项属于哪个任务（进程），一般为 current</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DECLARE_WAITQUEUE(name, tsk)</span><br></pre></td></tr></table></figure></li><li><p>添加/移除等待队列项</p><p>当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态。当设备可以访问以后再将进程对应的等待队列项从等待队列头中移除即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 添加等待队列项到等待队列头</span></span><br><span class="line"><span class="comment"> * @param q 等待队列头</span></span><br><span class="line"><span class="comment"> * @param wait 等待队列项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q,<span class="keyword">wait_queue_t</span> *wait)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将等待队列项从等待队列头中移除</span></span><br><span class="line"><span class="comment"> * @param q 等待队列头</span></span><br><span class="line"><span class="comment"> * @param wait 等待队列项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove_wait_queue</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q,<span class="keyword">wait_queue_t</span> *wait)</span></span></span><br></pre></td></tr></table></figure></li><li><p>等待唤醒</p><p>当设备可以使用的时候就要唤醒进入休眠态的进程，唤醒可以使用如下两个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 唤醒等待队列头下所有的进程</span></span><br><span class="line"><span class="comment"> * @param q 要唤醒的等待队列头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wake_up_interruptible</span><span class="params">(<span class="keyword">wait_queue_head_t</span> *q)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><code>wake_up</code> 函数可以唤醒处于 <code>TASK_INTERRUPTIBLE</code> 和 <code>TASK_UNINTERRUPTIBLE</code> 状态的进程，而 <code>wake_up_interruptible</code> 函数只能唤醒处于 <code>TASK_INTERRUPTIBLE</code> 状态的进程。</strong></p></li><li><p>等待事件</p><p>除了主动唤醒以外，也可以设置等待队列等待某个事件，当这个事件满足以后就自动唤醒等待队列中的进程，和等待事件有关的<code>API</code>函数如下。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>wait_event(wq, condition)</td><td>等待以 <code>wq</code> 为等待队列头的等待队列被唤醒，前提是 <code>condition</code> 条件必须满足(为真)，否则一直阻塞。此 函 数 会 将 进 程 设 置 为<code>TASK_UNINTERRUPTIBLE</code> 状态。</td></tr><tr><td>wait_event_timeout(wq, condition, timeout)</td><td>功能和 <code>wait_event</code> 类似，但是此函数可以添加超时时间，以 <code>jiffies</code> 为单位。此函数有返回值，如果返回 <code>0</code> 的话表示超时时间到，而且 <code>condition</code> 为假。为 <code>1</code> 的话表示 <code>condition</code> 为真，也就是条件满足了。</td></tr><tr><td>wait_event_interruptible(wq, condition)</td><td>与 <code>wait_event</code> 函数类似，但是此函数将进程设置为<code>TASK_INTERRUPTIBLE</code>，就是可以被信号打断。</td></tr><tr><td>wait_event_interruptible_timeout(wq,condition, timeout)</td><td>与 <code>wait_event_timeout</code> 函数类似，此函数也将进 程设置为<code>TASK_INTERRUPTIBLE</code>，可以被信号打断。</td></tr></tbody></table></li></ol><h3 id="1-3-轮询（非阻塞访问）"><a href="#1-3-轮询（非阻塞访问）" class="headerlink" title="1.3 轮询（非阻塞访问）"></a>1.3 轮询（非阻塞访问）</h3><p>如果用户应用程序以非阻塞的方式访问设备，设备驱动程序就要提供非阻塞的处理方式，也就是轮询。 <code>poll</code>、 <code>epoll</code> 和 <code>select</code> 可以用于处理轮询，应用程序通过 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 函数来查询设备是否可以操作，如果可以操作的话就从设备读取或者向设备写入数据。</p><p>当应用程序调用 <code>select</code>、 <code>epoll</code> 或 <code>poll</code> 函数的时候，设备驱动程序中的 <code>poll</code> 函数就会执行，因此需要在设备驱动程序中编写 <code>poll</code> 函数。</p><p>驱动里<code>poll</code>函数原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param filp 要打开的设备文件（文件描述符）</span></span><br><span class="line"><span class="comment"> * @param wait 结构体 poll_table_struct 类型指针，由应用程序传递进来。一般将此参数传递给 poll_wait 函数。</span></span><br><span class="line"><span class="comment"> * @return 向应用程序返回设备或者资源状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span><span class="params">(struct file *filp, struct poll_table_struct *wait)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return 可以返回的资源状态 */</span></span><br><span class="line">POLLIN <span class="comment">// 有数据可以读取。</span></span><br><span class="line">POLLPRI <span class="comment">// 有紧急的数据需要读取。</span></span><br><span class="line">POLLOUT <span class="comment">// 可以写数据。</span></span><br><span class="line">POLLERR<span class="comment">// 指定的文件描述符发生错误。</span></span><br><span class="line">POLLHUP<span class="comment">// 指定的文件描述符挂起。</span></span><br><span class="line">POLLNVAL<span class="comment">// 无效的请求。</span></span><br><span class="line">POLLRDNORM<span class="comment">// 等同于 POLLIN，普通数据可读</span></span><br></pre></td></tr></table></figure><p>需要在驱动程序的 <code>poll</code> 函数中调用 <code>poll_wait</code> 函数， <code>poll_wait</code> 函数不会引起阻塞，只是将应用程序添加到 <code>poll_table</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param filp 文件描述符</span></span><br><span class="line"><span class="comment"> * @param wait_address 要添加到 poll_table 中的等待队列头</span></span><br><span class="line"><span class="comment"> * @param p poll_table，就是file_operations 中 poll 函数的 wait 参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">poll_wait</span><span class="params">(struct file *filp, <span class="keyword">wait_queue_head_t</span> *wait_address, poll_table *p)</span></span></span><br></pre></td></tr></table></figure><ol><li><p><code>select</code>函数</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">&gt;* @param nfds 所要监视的这三类文件描述集合中，最大文件描述符加1。</span></span><br><span class="line"><span class="comment">&gt;* @param readfds 监视指定描述符集的读变化，也就是监视文件是否可读</span></span><br><span class="line"><span class="comment">&gt;* @param writefds 监视文件是否可以进行写操作</span></span><br><span class="line"><span class="comment">&gt;* @param exceptfds 监视这些文件的异常</span></span><br><span class="line"><span class="comment">&gt;* @param timeout 超时时间，为 NULL 的时候就表示无限期的等待。</span></span><br><span class="line"><span class="comment">&gt;* @return 0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作；-1，发生错误；其他值，可以进行操作的文件描述符个数。</span></span><br><span class="line"><span class="comment">&gt;*/</span></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span></span><br><span class="line"><span class="function"><span class="params">       fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="comment">/* timeval结构体 */</span></span><br><span class="line">&gt;<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec; <span class="comment">/* 秒 */</span></span><br><span class="line"><span class="keyword">long</span> tv_usec; <span class="comment">/* 微妙 */</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure><p>比如现在要从一个设备文件中读取数据，那么就可以定义一个 <code>fd_set</code> 变量，这个变量要传递给参数 <code>readfds</code>。当我们定义好一个 <code>fd_set</code> 变量以后可以使用如下所示几个宏进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><code>FD_ZERO</code> 用于将 <code>fd_set</code> 变量的所有位都清零， <code>FD_SET</code> 用于将 <code>fd_set</code> 变量的某个位置 <code>1</code>，也就是向 <code>fd_set</code> 添加一个文件描述符，参数 <code>fd</code> 就是要加入的文件描述符。<code>FD_CLR</code> 用于将<code>fd_set</code>变量的某个位清零，也就是将一个文件描述符从 <code>fd_set</code>中删除，参数 <code>fd</code> 就是要删除的文件描述符。 <code>FD_ISSET</code> 用于测试一个文件是否属于某个集合，参数 <code>fd</code> 就是要判断的文件描述符。</p><p>使用 <code>select</code> 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret, fd; <span class="comment">/* 要监视的文件描述符 */</span></span><br><span class="line">fd_set readfds; <span class="comment">/* 读操作文件描述符集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span><span class="comment">/* 超时结构体 */</span></span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(<span class="string">"dev_xxx"</span>, O_RDWR | O_NONBLOCK); <span class="comment">/* 非阻塞式访问 */</span></span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;readfds); <span class="comment">/* 清除 readfds */</span></span><br><span class="line">FD_SET(fd, &amp;readfds); <span class="comment">/* 将 fd 添加到 readfds 里面 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构造超时时间 */</span></span><br><span class="line">timeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">timeout.tv_usec = <span class="number">500000</span>; <span class="comment">/* 500ms */</span></span><br><span class="line"></span><br><span class="line">ret = select(fd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 超时 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"timeout!\r\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* 错误 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error!\r\n"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可以读取数据 */</span></span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fd, &amp;readfds)) &#123; <span class="comment">/* 判断是否为 fd 文件描述符 */</span></span><br><span class="line">        <span class="comment">/* 使用 read 函数读取数据 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>poll</code>函数</p><blockquote><p>在单个线程中， <code>select</code> 函数能够监视的文件描述符数量有最大的限制，一般为 <code>1024</code>，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用 <code>poll</code> 函数， <code>poll</code> 函数本质上和 <code>select</code> 没有太大的差别，但是 <code>poll</code> 函数没有最大文件描述符限制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param fds 要监视的文件描述符集合以及要监视的事件,为一个数组</span></span><br><span class="line"><span class="comment"> * @param nfds poll函数要监视的文件描述符数量</span></span><br><span class="line"><span class="comment"> * @param timeout 超时时间，单位为 ms。</span></span><br><span class="line"><span class="comment"> * @return 返回 revents 域中不为 0 的 pollfd 结构体个数，也就是发生事件或错误的文件描述符数量；0，超时；-1，发生错误，并且设置 errno 为错误类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pollfd 结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 文件描述符 */</span></span><br><span class="line">    short events; <span class="comment">/* 请求的事件 */</span></span><br><span class="line">    short revents; <span class="comment">/* 返回的事件 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pollfd</code> 结构体中 <code>fd</code> 是要监视的文件描述符，如果 <code>fd</code> 无效的话那么 <code>events</code> 监视事件也就无效，并且 <code>revents</code>返回 <code>0</code>。 <code>events</code>是要监视的事件，可监视的事件类型如下所示， <code>revents</code> 是返回参数，也就是返回的事件， 由 <code>Linux</code> 内核设置具体的返回事件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POLLIN <span class="comment">/* 有数据可以读取。*/</span></span><br><span class="line">POLLPRI <span class="comment">/* 有紧急的数据需要读取。 */</span></span><br><span class="line">POLLOUT <span class="comment">/* 可以写数据。 */</span></span><br><span class="line">POLLERR <span class="comment">/* 指定的文件描述符发生错误。 */</span></span><br><span class="line">POLLHUP <span class="comment">/* 指定的文件描述符挂起。 */</span></span><br><span class="line">POLLNVAL <span class="comment">/* 无效的请求。 */</span></span><br><span class="line">POLLRDNORM <span class="comment">/* 等同于 POLLIN */</span></span><br></pre></td></tr></table></figure><p>使用 <code>poll</code> 函数对某个设备驱动文件进行读非阻塞访问的操作示例如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">/* 要监视的文件描述符 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line"></span><br><span class="line">    fd = <span class="built_in">open</span>(filename, O_RDWR | O_NONBLOCK);<span class="comment">/* 非阻塞式访问 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造结构体 */</span></span><br><span class="line">    fds.fd = fd;</span><br><span class="line">    fds.events = POLLIN;<span class="comment">/* 监视数据是否可以读取 */</span></span><br><span class="line"></span><br><span class="line">    ret = poll(&amp;fds, <span class="number">1</span>, <span class="number">500</span>);<span class="comment">/* 轮询文件是否可操作，超时 500ms */</span></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123; <span class="comment">/* 数据有效 */</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* 读取数据 */</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;<span class="comment">/* 超时 */</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;<span class="comment">/* 错误 */</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>epoll</code>函数</p><blockquote><p>传统的 <code>selcet</code> 和 <code>poll</code> 函数都会随着所监听的 <code>fd</code> 数量的增加，出现效率低下的问题，而且 <code>poll</code> 函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此， <code>epoll</code> 应运而生， <code>epoll</code> 就是为处理大并发而准备的，一般常常在网络编程中使用 <code>epoll</code> 函数。应用程序需要先使用 <code>epoll_create</code> 函数创建一个 <code>epoll</code> 句柄。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  &gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param size 从Linux2.6.8开始此参数已无意义，随便填写一个大于0的值即可。</span></span><br><span class="line"><span class="comment">* @return epoll句柄，如果为-1的话表示创建失败。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &gt;int epoll_create(int size)；</span><br></pre></td></tr></table></figure><p><code>epoll</code> 句柄创建成功以后使用 <code>epoll_ctl</code> 函数向其中添加要监视的文件描述符以及监视的事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  &gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param epfd 要操作的epoll句柄，也就是使用epoll_create函数创建的epoll句柄。</span></span><br><span class="line"><span class="comment">* @param op 表示要对 epfd(epoll 句柄)进行的操作。</span></span><br><span class="line"><span class="comment">* @param fd 要监视的文件描述符。</span></span><br><span class="line"><span class="comment">* @param event 要监视的事件类型。</span></span><br><span class="line"><span class="comment">* @return 0，成功； -1，失败，并且设置 errno 的值为相应的错误码。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &gt;<span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line">  &gt;<span class="comment">/* op 可以选择的设置  */</span></span><br><span class="line">  &gt;EPOLL_CTL_ADD <span class="comment">// 向 epfd 添加文件参数 fd 表示的描述符。</span></span><br><span class="line">  &gt;EPOLL_CTL_MOD <span class="comment">// 修改参数 fd 的 event 事件。</span></span><br><span class="line">  &gt;EPOLL_CTL_DEL <span class="comment">// 从 epfd 中删除 fd 描述符。</span></span><br><span class="line"></span><br><span class="line">  &gt;<span class="comment">/* epoll_event 结构体 */</span></span><br><span class="line">  &gt;<span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;<span class="comment">/* epoll 事件 */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;<span class="comment">/* 用户数据 */</span></span><br><span class="line">  &gt;&#125;;</span><br></pre></td></tr></table></figure><p>结构体 <code>epoll_event</code> 的 <code>events</code> 成员变量表示要监视的事件，可选的事件如下，彼此之间可以进行或操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;EPOLLIN<span class="comment">// 有数据可以读取。</span></span><br><span class="line">&gt;EPOLLOUT<span class="comment">// 可以写数据。</span></span><br><span class="line">&gt;EPOLLPRI<span class="comment">// 有紧急的数据需要读取。</span></span><br><span class="line">&gt;EPOLLERR<span class="comment">// 指定的文件描述符发生错误。</span></span><br><span class="line">&gt;EPOLLHUP<span class="comment">// 指定的文件描述符挂起。</span></span><br><span class="line">&gt;EPOLLET<span class="comment">// 设置 epoll 为边沿触发，默认触发模式为水平触发。</span></span><br><span class="line">&gt;EPOLLONESHOT<span class="comment">// 一次性的监视，当监视完成以后还需要再次监视某个 fd，那么就需要将 fd 重新添加到 epoll 里面。</span></span><br></pre></td></tr></table></figure><p>一切都设置好以后应用程序就可以通过 <code>epoll_wait</code> 函数来等待事件的发生，类似 <code>select</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  &gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param epfd 要等待的 epoll</span></span><br><span class="line"><span class="comment">* @param events 指向 epoll_event 结构体的数组，当有事件发生的时候 Linux 内核会填写 events，调</span></span><br><span class="line"><span class="comment">  &gt;用者可以根据 events 判断发生了哪些事件。</span></span><br><span class="line"><span class="comment">* @param maxevents events 数组大小，必须大于0</span></span><br><span class="line"><span class="comment">* @param timeout 超时时间，单位为ms。</span></span><br><span class="line"><span class="comment">* @return 0，超时；-1，错误；其他值，准备就绪的文件描述符数量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  &gt;<span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong><code>epoll</code> 更多的是用在大规模的并发服务器上，因为在这种场合下 <code>select</code> 和 <code>poll</code> 并不适合，当设计到的文件描述符(<code>fd</code>)比较少的时候就适合用 <code>selcet</code> 和 <code>poll</code>。</strong></p></blockquote></li></ol><h2 id="二、编写试验驱动"><a href="#二、编写试验驱动" class="headerlink" title="二、编写试验驱动"></a>二、编写试验驱动</h2><h3 id="2-1-阻塞式访问驱动"><a href="#2-1-阻塞式访问驱动" class="headerlink" title="2.1 阻塞式访问驱动"></a>2.1 阻塞式访问驱动</h3><ol><li>等待事件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_NAME<span class="meta-string">"keyirq"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_NUM1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_VALUE0X01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVAKEY0XFF<span class="comment">/* 无效按键值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> gpio;<span class="comment">/* IO编号 */</span></span><br><span class="line"><span class="keyword">int</span> irqNum;<span class="comment">/* 中断号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> value;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">/* 名称 */</span></span><br><span class="line"><span class="keyword">irqreturn_t</span> (*handler)(<span class="keyword">int</span>, <span class="keyword">void</span>*);<span class="comment">/* 中断处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义设备驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">/* 设备ID */</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="keyword">int</span> minor;<span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* 字符设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">/* 设备类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span> <span class="title">key</span>[<span class="title">KEY_NUM</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定时器 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> keyValue;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">atomic_t</span> keyRelease;<span class="comment">/* 按键是否释放 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> r_wait;<span class="comment">/* 读等待队列头 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> <span class="title">keyirq</span>;</span><span class="comment">/* 定义一个keyirq设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;keyirq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyValue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyRelease;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待事件 */</span></span><br><span class="line">wait_event_interruptible(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;keyRelease));</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span>wait_event 不可以被信号打断，使用 kill -9 PID 无法杀掉任务</span></span><br><span class="line"><span class="comment">// wait_event(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;keyRelease));/* 等待按键值有效 */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">keyValue = atomic_read(&amp;dev-&gt;keyValue);</span><br><span class="line">keyRelease = atomic_read(&amp;dev-&gt;keyRelease);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyRelease)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 一次有效按键 */</span></span><br><span class="line"><span class="keyword">if</span> (keyValue &amp; <span class="number">0X80</span>)</span><br><span class="line">&#123;</span><br><span class="line">keyValue &amp;= ~<span class="number">0X80</span>;<span class="comment">// 去除标记</span></span><br><span class="line">ret = copy_to_user(buf, &amp;keyValue, <span class="keyword">sizeof</span>(keyValue));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">data_err:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">keyirq_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = keyirq_open,</span><br><span class="line">.<span class="built_in">release</span> = keyirq_release,</span><br><span class="line">.<span class="built_in">write</span> = keyirq_write,</span><br><span class="line">.<span class="built_in">read</span> = keyirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 用户参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">value = gpio_get_value(dev-&gt;key[<span class="number">0</span>].gpio);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键按下</span></span><br><span class="line">printk(<span class="string">"KEY0 Press!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键释放</span></span><br><span class="line">printk(<span class="string">"KEY0 Release!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value | <span class="number">0X80</span>);<span class="comment">// 打上标签，标记按键按下</span></span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒进程 */</span></span><br><span class="line"><span class="keyword">if</span>(atomic_read(&amp;dev-&gt;keyRelease))</span><br><span class="line">&#123;</span><br><span class="line">wake_up(&amp;dev-&gt;r_wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief key0 tasklet 处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 传递的参数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">key0_tasklet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器来延时消抖 */</span></span><br><span class="line">dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键中断处理函数</span></span><br><span class="line"><span class="comment"> * @param irq 中断号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">key0_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">tasklet_schedule(&amp;dev-&gt;key[<span class="number">0</span>].tasklet);<span class="comment">/* 调度对应的tasklet */</span></span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键初始化</span></span><br><span class="line"><span class="comment"> * @param dev 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 错误类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyio_init</span><span class="params">(struct keyirq_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键初始化 */</span></span><br><span class="line">dev-&gt;nd = of_find_node_by_path(<span class="string">"/key"</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_nd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可能有多个按键，因此需要根据实际数量来读取 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;key[i].gpio = of_get_named_gpio(dev-&gt;nd, <span class="string">"key-gpios"</span>, i);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;key[i].gpio &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_getGpio;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dev-&gt;key[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;key[i].name));</span><br><span class="line"><span class="built_in">sprintf</span>(dev-&gt;key[i].name, <span class="string">"KEY%d"</span>, i);</span><br><span class="line">ret = gpio_request(dev-&gt;key[i].gpio, dev-&gt;key[i].name);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_requestGpio;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_input(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setGpioDir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取中断号，两种方式皆可 */</span></span><br><span class="line">dev-&gt;key[i].irqNum = gpio_to_irq(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="comment">// dev-&gt;key[i].irqNum = irq_of_parse_and_map(dev-&gt;nd, i);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键中断初始化 */</span></span><br><span class="line">dev-&gt;key[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">dev-&gt;key[<span class="number">0</span>].value = KEY0_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 跳变沿触发方式 */</span></span><br><span class="line">ret = request_irq(dev-&gt;key[i].irqNum, dev-&gt;key[i].handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, dev-&gt;key[i].name, dev);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"irq %d request failed!\r\n"</span>, dev-&gt;key[i].irqNum);</span><br><span class="line"><span class="keyword">goto</span> fail_irq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>没有根据多个按键来初始化各自的tasklet,实际中需要根据情况来编写 */</span></span><br><span class="line">tasklet_init(&amp;dev-&gt;key[i].tasklet, key0_tasklet, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化定时器 */</span></span><br><span class="line">init_timer(&amp;dev-&gt;timer);</span><br><span class="line">dev-&gt;timer.function = timer_func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_irq:</span><br><span class="line">fail_setGpioDir:</span><br><span class="line"><span class="keyword">for</span> (i = i<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">gpio_free(dev-&gt;key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line">fail_requestGpio:</span><br><span class="line">fail_getGpio:</span><br><span class="line">fail_nd:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">keyirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备ID */</span></span><br><span class="line">keyirq.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(keyirq.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">keyirq.devid = MKDEV(keyirq.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(keyirq.devid, KEYIRQ_CNT, KEYIRQ_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;keyirq.devid, <span class="number">0</span>,KEYIRQ_CNT,KEYIRQ_NAME);</span><br><span class="line">keyirq.major = MAJOR(keyirq.devid);</span><br><span class="line">keyirq.minor = MINOR(keyirq.devid);</span><br><span class="line">printk(<span class="string">"dev Major ID:%d\r\n"</span>,keyirq.major);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化字符设备 */</span></span><br><span class="line">keyirq.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;keyirq.cdev, &amp;keyirq_fops);</span><br><span class="line">ret = cdev_add(&amp;keyirq.cdev, keyirq.devid, KEYIRQ_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备类 */</span></span><br><span class="line">keyirq<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">KEYIRQ_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">keyirq.device = device_create(keyirq.class, <span class="literal">NULL</span>, keyirq.devid, <span class="literal">NULL</span>, KEYIRQ_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化IO */</span></span><br><span class="line">ret = keyio_init(&amp;keyirq);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">atomic_set(&amp;keyirq.keyValue, INVAKEY);</span><br><span class="line">atomic_set(&amp;keyirq.keyRelease, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化等待队列头 */</span></span><br><span class="line">init_waitqueue_head(&amp;keyirq.r_wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_init:</span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(keyirq.devid, KEYIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">keyirq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 释放中断和IO */</span></span><br><span class="line">free_irq(keyirq.key[i].irqNum, &amp;keyirq);</span><br><span class="line">gpio_free(keyirq.key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除定时器 */</span></span><br><span class="line">del_timer_sync(&amp;keyirq.timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">unregister_chrdev_region(keyirq.devid,KEYIRQ_CNT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(keyirq_init);</span><br><span class="line">module_exit(keyirq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>等待队列项</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_NAME<span class="meta-string">"keyirq"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_NUM1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_VALUE0X01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVAKEY0XFF<span class="comment">/* 无效按键值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> gpio;<span class="comment">/* IO编号 */</span></span><br><span class="line"><span class="keyword">int</span> irqNum;<span class="comment">/* 中断号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> value;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">/* 名称 */</span></span><br><span class="line"><span class="keyword">irqreturn_t</span> (*handler)(<span class="keyword">int</span>, <span class="keyword">void</span>*);<span class="comment">/* 中断处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义设备驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">/* 设备ID */</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="keyword">int</span> minor;<span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* 字符设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">/* 设备类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span> <span class="title">key</span>[<span class="title">KEY_NUM</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定时器 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> keyValue;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">atomic_t</span> keyRelease;<span class="comment">/* 按键是否释放 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> r_wait;<span class="comment">/* 读等待队列头 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> <span class="title">keyirq</span>;</span><span class="comment">/* 定义一个keyirq设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;keyirq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyValue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyRelease;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/* 等待事件 */</span></span><br><span class="line">wait_event_interruptible(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;keyRelease));<span class="comment">/* 等待按键值有效 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span>wait_event 不可以被信号打断，使用 kill -9 PID 无法杀掉任务</span></span><br><span class="line"><span class="comment">// wait_event(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;keyRelease));/* 等待按键值有效 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 等待队列项 */</span></span><br><span class="line">DECLARE_WAITQUEUE(wait, current);<span class="comment">/* 定义一个等待队列项 */</span></span><br><span class="line"></span><br><span class="line">add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);<span class="comment">/* 将等待队列项添加到等待队列头中 */</span></span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);<span class="comment">/* 设置当前进程为可以被打断的状态 */</span></span><br><span class="line">schedule();<span class="comment">/* 切换 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒后，进程从这里运行 */</span></span><br><span class="line"><span class="keyword">if</span> (signal_pending(current))<span class="comment">/* 判断当前进程是否有信号需要处理，返回值不为零表示有信号需要进行处理 */</span></span><br><span class="line">&#123;</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyValue = atomic_read(&amp;dev-&gt;keyValue);</span><br><span class="line">keyRelease = atomic_read(&amp;dev-&gt;keyRelease);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyRelease)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 一次有效按键 */</span></span><br><span class="line"><span class="keyword">if</span> (keyValue &amp; <span class="number">0X80</span>)</span><br><span class="line">&#123;</span><br><span class="line">keyValue &amp;= ~<span class="number">0X80</span>;<span class="comment">// 去除标记</span></span><br><span class="line">ret = copy_to_user(buf, &amp;keyValue, <span class="keyword">sizeof</span>(keyValue));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_err:</span><br><span class="line">__set_current_state(TASK_RUNNING);<span class="comment">/* 设置当前任务为运行状态 */</span></span><br><span class="line">remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);<span class="comment">/* 将对应的队列项从等待队列头删除 */</span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">keyirq_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = keyirq_open,</span><br><span class="line">.<span class="built_in">release</span> = keyirq_release,</span><br><span class="line">.<span class="built_in">write</span> = keyirq_write,</span><br><span class="line">.<span class="built_in">read</span> = keyirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 用户参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">value = gpio_get_value(dev-&gt;key[<span class="number">0</span>].gpio);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键按下</span></span><br><span class="line">printk(<span class="string">"KEY0 Press!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键释放</span></span><br><span class="line">printk(<span class="string">"KEY0 Release!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value | <span class="number">0X80</span>);<span class="comment">// 打上标签，标记按键按下</span></span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒进程 */</span></span><br><span class="line"><span class="keyword">if</span>(atomic_read(&amp;dev-&gt;keyRelease))</span><br><span class="line">&#123;</span><br><span class="line">wake_up(&amp;dev-&gt;r_wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief key0 tasklet 处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 传递的参数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">key0_tasklet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器来延时消抖 */</span></span><br><span class="line">dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键中断处理函数</span></span><br><span class="line"><span class="comment"> * @param irq 中断号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">key0_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">tasklet_schedule(&amp;dev-&gt;key[<span class="number">0</span>].tasklet);<span class="comment">/* 调度对应的tasklet */</span></span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键初始化</span></span><br><span class="line"><span class="comment"> * @param dev 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 错误类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyio_init</span><span class="params">(struct keyirq_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键初始化 */</span></span><br><span class="line">dev-&gt;nd = of_find_node_by_path(<span class="string">"/key"</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_nd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可能有多个按键，因此需要根据实际数量来读取 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;key[i].gpio = of_get_named_gpio(dev-&gt;nd, <span class="string">"key-gpios"</span>, i);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;key[i].gpio &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_getGpio;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dev-&gt;key[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;key[i].name));</span><br><span class="line"><span class="built_in">sprintf</span>(dev-&gt;key[i].name, <span class="string">"KEY%d"</span>, i);</span><br><span class="line">ret = gpio_request(dev-&gt;key[i].gpio, dev-&gt;key[i].name);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_requestGpio;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_input(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setGpioDir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取中断号，两种方式皆可 */</span></span><br><span class="line">dev-&gt;key[i].irqNum = gpio_to_irq(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="comment">// dev-&gt;key[i].irqNum = irq_of_parse_and_map(dev-&gt;nd, i);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键中断初始化 */</span></span><br><span class="line">dev-&gt;key[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">dev-&gt;key[<span class="number">0</span>].value = KEY0_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 跳变沿触发方式 */</span></span><br><span class="line">ret = request_irq(dev-&gt;key[i].irqNum, dev-&gt;key[i].handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, dev-&gt;key[i].name, dev);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"irq %d request failed!\r\n"</span>, dev-&gt;key[i].irqNum);</span><br><span class="line"><span class="keyword">goto</span> fail_irq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>没有根据多个按键来初始化各自的tasklet,实际中需要根据情况来编写 */</span></span><br><span class="line">tasklet_init(&amp;dev-&gt;key[i].tasklet, key0_tasklet, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化定时器 */</span></span><br><span class="line">init_timer(&amp;dev-&gt;timer);</span><br><span class="line">dev-&gt;timer.function = timer_func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_irq:</span><br><span class="line">fail_setGpioDir:</span><br><span class="line"><span class="keyword">for</span> (i = i<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">gpio_free(dev-&gt;key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line">fail_requestGpio:</span><br><span class="line">fail_getGpio:</span><br><span class="line">fail_nd:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">keyirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备ID */</span></span><br><span class="line">keyirq.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(keyirq.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">keyirq.devid = MKDEV(keyirq.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(keyirq.devid, KEYIRQ_CNT, KEYIRQ_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;keyirq.devid, <span class="number">0</span>,KEYIRQ_CNT,KEYIRQ_NAME);</span><br><span class="line">keyirq.major = MAJOR(keyirq.devid);</span><br><span class="line">keyirq.minor = MINOR(keyirq.devid);</span><br><span class="line">printk(<span class="string">"dev Major ID:%d\r\n"</span>,keyirq.major);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化字符设备 */</span></span><br><span class="line">keyirq.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;keyirq.cdev, &amp;keyirq_fops);</span><br><span class="line">ret = cdev_add(&amp;keyirq.cdev, keyirq.devid, KEYIRQ_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备类 */</span></span><br><span class="line">keyirq<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">KEYIRQ_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">keyirq.device = device_create(keyirq.class, <span class="literal">NULL</span>, keyirq.devid, <span class="literal">NULL</span>, KEYIRQ_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化IO */</span></span><br><span class="line">ret = keyio_init(&amp;keyirq);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">atomic_set(&amp;keyirq.keyValue, INVAKEY);</span><br><span class="line">atomic_set(&amp;keyirq.keyRelease, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化等待队列头 */</span></span><br><span class="line">init_waitqueue_head(&amp;keyirq.r_wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_init:</span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(keyirq.devid, KEYIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">keyirq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 释放中断和IO */</span></span><br><span class="line">free_irq(keyirq.key[i].irqNum, &amp;keyirq);</span><br><span class="line">gpio_free(keyirq.key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除定时器 */</span></span><br><span class="line">del_timer_sync(&amp;keyirq.timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">unregister_chrdev_region(keyirq.devid,KEYIRQ_CNT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(keyirq_init);</span><br><span class="line">module_exit(keyirq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-非阻塞式访问"><a href="#2-2-非阻塞式访问" class="headerlink" title="2.2 非阻塞式访问"></a>2.2 非阻塞式访问</h3><ol><li>驱动程序</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_NAME<span class="meta-string">"keyirq"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_NUM1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_VALUE0X01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVAKEY0XFF<span class="comment">/* 无效按键值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> gpio;<span class="comment">/* IO编号 */</span></span><br><span class="line"><span class="keyword">int</span> irqNum;<span class="comment">/* 中断号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> value;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">/* 名称 */</span></span><br><span class="line"><span class="keyword">irqreturn_t</span> (*handler)(<span class="keyword">int</span>, <span class="keyword">void</span>*);<span class="comment">/* 中断处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义设备驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">/* 设备ID */</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="keyword">int</span> minor;<span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* 字符设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">/* 设备类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span> <span class="title">key</span>[<span class="title">KEY_NUM</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定时器 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> keyValue;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">atomic_t</span> keyRelease;<span class="comment">/* 按键是否释放 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> r_wait;<span class="comment">/* 读等待队列头 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> <span class="title">keyirq</span>;</span><span class="comment">/* 定义一个keyirq设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;keyirq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyValue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyRelease;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(filp-&gt;f_flags &amp; O_NONBLOCK) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 非阻塞方式访问 */</span></span><br><span class="line"><span class="keyword">if</span>(atomic_read(&amp;dev-&gt;keyRelease) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 阻塞访问方式 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 等待事件 */</span></span><br><span class="line">wait_event_interruptible(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;keyRelease));<span class="comment">/* 等待按键值有效 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span>wait_event 不可以被信号打断，使用 kill -9 PID 无法杀掉任务</span></span><br><span class="line"><span class="comment">// wait_event(dev-&gt;r_wait, atomic_read(&amp;dev-&gt;keyRelease));/* 等待按键值有效 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">DECLARE_WAITQUEUE(wait, current);<span class="comment">/* 定义一个等待队列项 */</span></span><br><span class="line">add_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);<span class="comment">/* 将等待队列项添加到等待队列头中 */</span></span><br><span class="line">__set_current_state(TASK_INTERRUPTIBLE);<span class="comment">/* 设置当前进程为可以被打断的状态 */</span></span><br><span class="line">schedule();<span class="comment">/* 切换 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒后，进程从这里运行 */</span></span><br><span class="line"><span class="keyword">if</span> (signal_pending(current))<span class="comment">/* 判断当前进程是否有信号需要处理，返回值不为零表示有信号需要进行处理 */</span></span><br><span class="line">&#123;</span><br><span class="line">ret = -ERESTARTSYS;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">keyValue = atomic_read(&amp;dev-&gt;keyValue);</span><br><span class="line">keyRelease = atomic_read(&amp;dev-&gt;keyRelease);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyRelease)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 一次有效按键 */</span></span><br><span class="line"><span class="keyword">if</span> (keyValue &amp; <span class="number">0X80</span>)</span><br><span class="line">&#123;</span><br><span class="line">keyValue &amp;= ~<span class="number">0X80</span>;<span class="comment">// 去除标记</span></span><br><span class="line">ret = copy_to_user(buf, &amp;keyValue, <span class="keyword">sizeof</span>(keyValue));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_err:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">__set_current_state(TASK_RUNNING);<span class="comment">/* 设置当前任务为运行状态 */</span></span><br><span class="line">remove_wait_queue(&amp;dev-&gt;r_wait, &amp;wait);<span class="comment">/* 将对应的队列项从等待队列头删除 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">keyirq_poll</span><span class="params">(struct file *filp, struct poll_table_struct *wait)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">poll_wait(filp, &amp;dev-&gt;r_wait, wait);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 是否可读 */</span></span><br><span class="line"><span class="keyword">if</span> (atomic_read(&amp;dev-&gt;keyRelease))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 按键按下，可读 */</span></span><br><span class="line">mask = POLL_IN | POLLRDNORM;<span class="comment">/* 返回POLL_IN */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">keyirq_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = keyirq_open,</span><br><span class="line">.<span class="built_in">release</span> = keyirq_release,</span><br><span class="line">.<span class="built_in">write</span> = keyirq_write,</span><br><span class="line">.<span class="built_in">read</span> = keyirq_read,</span><br><span class="line">.poll = keyirq_poll, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 用户参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">value = gpio_get_value(dev-&gt;key[<span class="number">0</span>].gpio);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键按下</span></span><br><span class="line">printk(<span class="string">"KEY0 Press!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键释放</span></span><br><span class="line">printk(<span class="string">"KEY0 Release!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value | <span class="number">0X80</span>);<span class="comment">// 打上标签，标记按键按下</span></span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 唤醒进程 */</span></span><br><span class="line"><span class="keyword">if</span>(atomic_read(&amp;dev-&gt;keyRelease))</span><br><span class="line">&#123;</span><br><span class="line">wake_up(&amp;dev-&gt;r_wait);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief key0 tasklet 处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 传递的参数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">key0_tasklet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器来延时消抖 */</span></span><br><span class="line">dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键中断处理函数</span></span><br><span class="line"><span class="comment"> * @param irq 中断号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">key0_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">tasklet_schedule(&amp;dev-&gt;key[<span class="number">0</span>].tasklet);<span class="comment">/* 调度对应的tasklet */</span></span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键初始化</span></span><br><span class="line"><span class="comment"> * @param dev 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 错误类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyio_init</span><span class="params">(struct keyirq_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键初始化 */</span></span><br><span class="line">dev-&gt;nd = of_find_node_by_path(<span class="string">"/key"</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_nd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可能有多个按键，因此需要根据实际数量来读取 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;key[i].gpio = of_get_named_gpio(dev-&gt;nd, <span class="string">"key-gpios"</span>, i);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;key[i].gpio &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_getGpio;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dev-&gt;key[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;key[i].name));</span><br><span class="line"><span class="built_in">sprintf</span>(dev-&gt;key[i].name, <span class="string">"KEY%d"</span>, i);</span><br><span class="line">ret = gpio_request(dev-&gt;key[i].gpio, dev-&gt;key[i].name);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_requestGpio;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_input(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setGpioDir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取中断号，两种方式皆可 */</span></span><br><span class="line">dev-&gt;key[i].irqNum = gpio_to_irq(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="comment">// dev-&gt;key[i].irqNum = irq_of_parse_and_map(dev-&gt;nd, i);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键中断初始化 */</span></span><br><span class="line">dev-&gt;key[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">dev-&gt;key[<span class="number">0</span>].value = KEY0_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 跳变沿触发方式 */</span></span><br><span class="line">ret = request_irq(dev-&gt;key[i].irqNum, dev-&gt;key[i].handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, dev-&gt;key[i].name, dev);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"irq %d request failed!\r\n"</span>, dev-&gt;key[i].irqNum);</span><br><span class="line"><span class="keyword">goto</span> fail_irq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>没有根据多个按键来初始化各自的tasklet,实际中需要根据情况来编写 */</span></span><br><span class="line">tasklet_init(&amp;dev-&gt;key[i].tasklet, key0_tasklet, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化定时器 */</span></span><br><span class="line">init_timer(&amp;dev-&gt;timer);</span><br><span class="line">dev-&gt;timer.function = timer_func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_irq:</span><br><span class="line">fail_setGpioDir:</span><br><span class="line"><span class="keyword">for</span> (i = i<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">gpio_free(dev-&gt;key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line">fail_requestGpio:</span><br><span class="line">fail_getGpio:</span><br><span class="line">fail_nd:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">keyirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备ID */</span></span><br><span class="line">keyirq.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(keyirq.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">keyirq.devid = MKDEV(keyirq.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(keyirq.devid, KEYIRQ_CNT, KEYIRQ_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;keyirq.devid, <span class="number">0</span>,KEYIRQ_CNT,KEYIRQ_NAME);</span><br><span class="line">keyirq.major = MAJOR(keyirq.devid);</span><br><span class="line">keyirq.minor = MINOR(keyirq.devid);</span><br><span class="line">printk(<span class="string">"dev Major ID:%d\r\n"</span>,keyirq.major);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化字符设备 */</span></span><br><span class="line">keyirq.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;keyirq.cdev, &amp;keyirq_fops);</span><br><span class="line">ret = cdev_add(&amp;keyirq.cdev, keyirq.devid, KEYIRQ_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备类 */</span></span><br><span class="line">keyirq<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">KEYIRQ_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">keyirq.device = device_create(keyirq.class, <span class="literal">NULL</span>, keyirq.devid, <span class="literal">NULL</span>, KEYIRQ_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化IO */</span></span><br><span class="line">ret = keyio_init(&amp;keyirq);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">atomic_set(&amp;keyirq.keyValue, INVAKEY);</span><br><span class="line">atomic_set(&amp;keyirq.keyRelease, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化等待队列头 */</span></span><br><span class="line">init_waitqueue_head(&amp;keyirq.r_wait);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_init:</span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(keyirq.devid, KEYIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">keyirq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 释放中断和IO */</span></span><br><span class="line">free_irq(keyirq.key[i].irqNum, &amp;keyirq);</span><br><span class="line">gpio_free(keyirq.key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除定时器 */</span></span><br><span class="line">del_timer_sync(&amp;keyirq.timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">unregister_chrdev_region(keyirq.devid,KEYIRQ_CNT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(keyirq_init);</span><br><span class="line">module_exit(keyirq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>测试APP程序</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ./keyReadAPP /dev/keyirq</span></span><br><span class="line"><span class="comment"> * @param argc 应用程序参数个数</span></span><br><span class="line"><span class="comment"> * @param argv 保存的参数，字符串形式。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line"><span class="comment">/* 使用select */</span></span><br><span class="line"><span class="comment">// fd_set readfds;/*  */</span></span><br><span class="line"><span class="comment">// struct timeval timeout;/* 超时时间 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用poll */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (argc != 3)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("输入错误\r\n");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(filename, O_RDWR | O_NONBLOCK);<span class="comment">/* 非阻塞方式打开 */</span></span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: Open %s fail.\r\n"</span>,filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 循环读取 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/* 使用select */</span></span><br><span class="line">FD_ZERO(&amp;readfds);</span><br><span class="line">FD_SET(fd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">timeout.tv_sec = <span class="number">0</span>;</span><br><span class="line">timeout.tv_usec = <span class="number">500000</span>;<span class="comment">/* 超时时间500毫秒 */</span></span><br><span class="line">ret = select(fd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">switch</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">/* 超时 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"select 超时\r\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:<span class="comment">/* 错误 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">/* 可以读取数据 */</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(fd, &amp;readfds))</span><br><span class="line">&#123;</span><br><span class="line">ret = <span class="built_in">read</span>(fd, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"keyValue = %#x\r\n"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用poll */</span></span><br><span class="line">fds.fd = fd;</span><br><span class="line">fds.events = POLLIN;</span><br><span class="line">ret = poll(&amp;fds, <span class="number">1</span>, <span class="number">500</span>);<span class="comment">/* 超时时间500ms */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 超时 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"poll 超时\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 错误 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 可以读取 */</span></span><br><span class="line"><span class="keyword">if</span> (fds.revents | POLLIN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 可读取 */</span></span><br><span class="line">ret = <span class="built_in">read</span>(fd, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"keyValue = %#x\r\n"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 */</span></span><br><span class="line">ret = <span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: Close %s fail.\r\n"</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（九）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89.html</id>
    <published>2021-01-08T03:19:03.000Z</published>
    <updated>2021-01-08T03:20:56.385Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="一、Linux内核中断处理"><a href="#一、Linux内核中断处理" class="headerlink" title="一、Linux内核中断处理"></a>一、Linux内核中断处理</h2><h3 id="1-1-裸机中断"><a href="#1-1-裸机中断" class="headerlink" title="1.1 裸机中断"></a>1.1 裸机中断</h3><ul><li>使能中断，初始化相应的寄存器。</li><li>注册中断服务函数，也就是向<code>irqTable</code>数组（裸机例程）的指定标号处写入中断服务函数。</li><li>中断发生后进入<code>IRQ</code>中断服务函数，在<code>IRQ</code>中断服务函数中，根据中断号在<code>irqTable</code>里面查找具体的中断处理函数，找到以后执行相应的中断处理函数。</li></ul><a id="more"></a><h3 id="1-2-Linux中断"><a href="#1-2-Linux中断" class="headerlink" title="1.2 Linux中断"></a>1.2 Linux中断</h3><ul><li><p>先知道要使用的中断对应的中断号。</p></li><li><p>根据终端号申请<code>request_irq</code>，<code>request_irq</code>函数可能会导致睡眠，此函数同时会激活中断。</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @param irq 中断号</span></span><br><span class="line"><span class="comment"> * @param handler 中断服务函数 </span></span><br><span class="line"><span class="comment"> * @param flags 中断标志、中断触发方式</span></span><br><span class="line"><span class="comment"> * @param name 中断名字</span></span><br><span class="line"><span class="comment"> * @param dev 使用共享中断时，唯一用来区分的标志。当多个设备共享一个中断线，共享的所有中断都必须指定此标志。</span></span><br><span class="line"><span class="comment"> * @return 0 中断申请成功，其他负值 中断申请失败，如果返回 -EBUSY 的话表示中断已经被申请了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">request_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">irq_handler_t</span> handler, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">unsigned</span> <span class="keyword">long</span> flags, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *dev)</span></span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>不再使用中断时，需要释放中断<code>free_irq</code>。</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @param irq 中断号</span></span><br><span class="line"><span class="comment"> * @param dev 如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。</span></span><br><span class="line"><span class="comment"> *   共享中断只有在释放最后中断处理函数的时候才会被禁止掉。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq, <span class="keyword">void</span> *dev)</span></span>;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>在使用<code>request_irq</code>函数申请中断的时候需要设置中断处理函数，中断处理函数格式如下所示</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">irqreturn_t</span> (*<span class="keyword">irq_handler_t</span>) (<span class="keyword">int</span>, <span class="keyword">void</span> *)</span><br></pre></td></tr></table></figure><p>第一个参数是要中断处理函数要相应的中断号。第二个参数是一个指向 <code>void</code> 的指针，也就是个通用指针，需要与 <code>request_irq</code> 函数的 <code>dev</code> 参数保持一致。用于区分共享中断的不同设备，<code>dev</code> 也可以指向设备数据结构。中断处理函数的返回值为 <code>irqreturn_t</code> 类型， <code>irqreturn_t</code> 类型定义如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> irqreturn &#123;</span><br><span class="line"> IRQ_NONE = (<span class="number">0</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line"> IRQ_HANDLED = (<span class="number">1</span> &lt;&lt; <span class="number">0</span>),</span><br><span class="line"> IRQ_WAKE_THREAD = (<span class="number">1</span> &lt;&lt; <span class="number">1</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> irqreturn <span class="keyword">irqreturn_t</span>;</span><br></pre></td></tr></table></figure><p><code>irqreturn_t</code>是个枚举类型，一共有三种返回值。一般中断服务函数返回值使用如下形式：</p><p><code>return IRQ_RETVAL(IRQ_HANDLED)</code></p></blockquote></li><li><p>中断使能和禁止</p><blockquote><p><code>enable_irq</code> 和 <code>disable_irq</code> 用于使能和禁止指定的中断，<code>irq</code> 就是要禁止的中断号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span>;</span><br></pre></td></tr></table></figure><p><code>disable_irq</code>函数要等到当前正在执行的中断处理函数执行完才返回，因此需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。在这种情况下，可以使用另外一个中断禁止函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disable_irq_nosync</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> irq)</span></span></span><br></pre></td></tr></table></figure><p><code>disable_irq_nosync</code> 函数调用以后立即返回，不会等待当前中断处理程序执行完毕。</p><hr><p>上面三个函数都是使能或者禁止某一个中断，有时候我们需要关闭当前处理器的整个中断系统，也就是在学习 <code>STM32</code> 的时候常说的关闭全局中断，这个时候可以使用如下两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_enable();</span><br><span class="line">local_irq_disable();</span><br></pre></td></tr></table></figure><p><code>local_irq_enable</code> 用于使能当前处理器中断系统，<code>local_irq_disable</code>用于禁止当前处理器中断系统。</p><hr><p>但是在任务中使用这两个函数会出现问题。比如假如 <code>A</code> 任务调用 <code>local_irq_disable</code> 关闭全局中断10秒，当关闭了2秒的时候 <code>B</code> 任务开始运行， <code>B</code> 任务也调用 <code>local_irq_disable</code> 关闭全局中断3秒， 3秒以后 <code>B</code> 任务调用 <code>local_irq_enable</code> 函数将全局中断打开了。此时才过去 2+3=5 秒的时间，然后全局中断就被打开了，此时 <code>A</code> 任务要关闭10秒全局中断的愿望就破灭了，然后 <code>A</code> 任务就“生气了”，结果很严重，可能系统都要被<code>A</code>任务整崩溃。为了解决这个问题， <code>B</code> 任务不能直接简单粗暴的通过<code>local_irq_enable</code> 函数来打开全局中断，而是将中断状态恢复到以前的状态，要考虑到别的任务的感受，此时就要用到下面两个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_irq_save(flags);</span><br><span class="line">local_irq_restore(flags);</span><br></pre></td></tr></table></figure><p>这两个函数是一对， <code>local_irq_save</code> 函数用于禁止中断，并且将中断状态保存在 <code>flags</code> 中。<br><code>local_irq_restore</code> 用于恢复中断，将中断恢复到 <code>flags</code> 状态。</p></blockquote></li></ul><h3 id="1-3-上半部和下半部"><a href="#1-3-上半部和下半部" class="headerlink" title="1.3 上半部和下半部"></a>1.3 上半部和下半部</h3><ul><li><p>上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。</p></li><li><p>下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。</p></li><li><p>关于代码属于上半部或下半部的参考</p><blockquote><ol><li>如果要处理的内容不希望被其他中断打断，那么可以放到上半部。</li><li>如果要处理的任务对时间敏感，可以放到上半部。</li><li>如果要处理的任务与硬件有关，可以放到上半部。</li><li>除了上述三点以外的其他任务，优先考虑放到下半部。</li></ol></blockquote></li></ul><hr><p><strong><code>Linux</code>对下半部的处理方式。</strong></p><h4 id="1-3-1-软中断"><a href="#1-3-1-软中断" class="headerlink" title="1.3.1 软中断"></a>1.3.1 软中断</h4><p><strong>软中断必须在编译的时候静态注册（写入到内核中）！软中断不要去用。</strong></p><p><code>Linux</code> 内核使用结构体<code>softirq_action</code> 表示软中断，<code>softirq_action</code>结构体定义在文件 <code>include/linux/interrupt.h</code> 中，内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span> (*action)(struct softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>kernel/softirq.c</code> 文件中一共定义了 10 个软中断，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span></span><br></pre></td></tr></table></figure><p><code>NR_SOFTIRQS</code> 是枚举类型，定义在文件 <code>include/linux/interrupt.h</code> 中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> </span><br><span class="line">&#123;</span><br><span class="line">    HI_SOFTIRQ = <span class="number">0</span>, <span class="comment">/* 高优先级软中断 */</span></span><br><span class="line">    TIMER_SOFTIRQ, <span class="comment">/* 定时器软中断 */</span></span><br><span class="line">    NET_TX_SOFTIRQ, <span class="comment">/* 网络数据发送软中断 */</span></span><br><span class="line">    NET_RX_SOFTIRQ,<span class="comment">/* 网络数据接收软中断 */</span></span><br><span class="line">    BLOCK_SOFTIRQ,</span><br><span class="line">    BLOCK_IOPOLL_SOFTIRQ,</span><br><span class="line">    TASKLET_SOFTIRQ,<span class="comment">/* tasklet 软中断 */</span></span><br><span class="line">    SCHED_SOFTIRQ,<span class="comment">/* 调度软中断 */</span></span><br><span class="line">    HRTIMER_SOFTIRQ,<span class="comment">/* 高精度定时器软中断 */</span></span><br><span class="line">    RCU_SOFTIRQ,<span class="comment">/* RCU 软中断 */</span></span><br><span class="line">    NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>softirq_action</code> 结构体中的 <code>action</code> 成员变量就是软中断的服务函数，数组 <code>softirq_vec</code> 是个全局数组，因此所有的 <code>CPU</code>(对于 <code>SMP</code> 系统而言)都可以访问到，每个 <code>CPU</code> 都有自己的触发和控制机制，并且只执行自己所触发的软中断。但是各个 <code>CPU</code> 所执行的软中断服务函数确是相同的，都是数组 <code>softirq_vec</code> 中定义的 <code>action</code> 函数。</p><hr><ul><li><p>要使用软中断要先注册。</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @brief 注册软中断服务函数</span></span><br><span class="line"><span class="comment"> * @param nr 要开启的软中断 是上面枚举中的一个。</span></span><br><span class="line"><span class="comment"> * @param action 软中断对应的处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_softirq</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span> (*action)(struct softirq_action *))</span></span></span><br></pre></td></tr></table></figure><p>软中断必须在编译的时候静态注册！</p></blockquote></li><li><p>触发软中断</p><blockquote><p>注册好软中断以后需要通过 <code>raise_softirq</code> 函数触发， <code>raise_softirq</code> 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @brief 触发软中断</span></span><br><span class="line"><span class="comment"> * @param nr 要触发的软中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">raise_softirq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h4 id="1-3-2-tasklet"><a href="#1-3-2-tasklet" class="headerlink" title="1.3.2 tasklet"></a>1.3.2 tasklet</h4><p><code>tasklet</code> 是利用软中断来实现的另外一种下半部机制，建议使用 <code>tasklet</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span> <span class="comment">/* 下一个 tasklet */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state; <span class="comment">/* tasklet 状态 */</span></span><br><span class="line">    <span class="keyword">atomic_t</span> count; <span class="comment">/* 计数器，记录对 tasklet 的引用数 */</span></span><br><span class="line">    <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);<span class="comment">/* tasklet 执行的函数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data;<span class="comment">/* 函数 func 的参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要使用 <code>tasklet</code>，必须先定义一个 <code>tasklet</code>，然后使用 <code>tasklet_init</code> 函数初始化 <code>tasklet</code>，<code>taskled_init</code> 函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @brief 初始化 tasklet</span></span><br><span class="line"><span class="comment"> * @param t 要初始化的 tasklet</span></span><br><span class="line"><span class="comment"> * @param func tasklet 的处理函数。</span></span><br><span class="line"><span class="comment"> * @param data 要传递给 func 函数的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t, <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>), <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span>;</span><br></pre></td></tr></table></figure><p>也 可 以 使 用 宏 <code>DECLARE_TASKLET</code> 来 一 次 性 完 成 <code>tasklet</code> 的 定 义 和 初 始 化 ，<code>DECLARE_TASKLET</code> 定义在 <code>include/linux/interrupt.h</code> 文件中，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* name 为要定义的 tasklet 名字，</span></span><br><span class="line"><span class="comment"> * 这个名字就是一个 tasklet_struct 类型的结构变量，</span></span><br><span class="line"><span class="comment"> * func 就是 tasklet 的处理函数，data 是传递给 func 函数的参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DECLARE_TASKLET(name, func, data);</span><br></pre></td></tr></table></figure><p>在上半部，也就是中断处理函数中调用 <code>tasklet_schedule</code> 函数就能使 <code>tasklet</code> 在合适的时间运<br>行， <code>tasklet_schedule</code> 函数原型如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @param t 要调度的 tasklet，也就是 DECLARE_TASKLET 宏里面的 name。*/</span></span><br><span class="line">void tasklet_schedule(struct tasklet_struct *t)；</span><br></pre></td></tr></table></figure><hr><p><strong><code>tasklet</code> 使用顺序：</strong></p><ol><li>定义一个<code>tasklet</code>。</li><li>初始化<code>tasklet</code>，重点是设置对应的处理函数。</li><li>在上半部中调用<code>tasklet_schedule</code>函数，使 <code>tasklet</code> 在合适的时间运行。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义 taselet */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">testtasklet</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* tasklet 处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testtasklet_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* tasklet 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">test_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 调度 tasklet */</span></span><br><span class="line">    tasklet_schedule(&amp;testtasklet);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">xxxx_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 初始化 tasklet */</span></span><br><span class="line">    tasklet_init(&amp;testtasklet, testtasklet_func, data);</span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">"xxx"</span>, &amp;xxx_dev);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-工作队列"><a href="#1-3-3-工作队列" class="headerlink" title="1.3.3 工作队列"></a>1.3.3 工作队列</h4><p>工作队列是另外一种下半部执行方式，工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。因此如果要推后的工作可以睡眠那么就可以选择工作队列，否则的话就只能选择软中断或 <code>tasklet</code>。</p><p><code>Linux</code> 内核使用 <code>work_struct</code> 结构体表示一个工作，内容如下(省略掉条件编译)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> func; <span class="comment">/* 工作队列处理函数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些工作组织成工作队列，工作队列使用 <code>workqueue_struct</code> 结构体表示，内容如下(省略掉条件编译)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="keyword">int</span> work_color;</span><br><span class="line">    <span class="keyword">int</span> flush_color;</span><br><span class="line">    <span class="keyword">atomic_t</span> nr_pwqs_to_flush;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span> *<span class="title">first_flusher</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_queue</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">flusher_overflow</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">maydays</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line">    <span class="keyword">int</span> nr_drainers;</span><br><span class="line">    <span class="keyword">int</span> saved_max_active;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">unbound_attrs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">dfl_pwq</span>;</span></span><br><span class="line">    <span class="keyword">char</span> name[WQ_NAME_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags ____cacheline_aligned;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Linux</code> 内核使用工作者线程<code>(worker thread)</code>来处理工作队列中的各个工作， <code>Linux</code> 内核使用<code>worker</code> 结构体表示工作者线程， <code>worker</code> 结构体内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">hentry</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_work</span>;</span></span><br><span class="line">    <span class="keyword">work_func_t</span> current_func;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">current_pwq</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> desc_valid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">scheduled</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> last_active;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> desc[WORKER_DESC_LEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">rescue_wq</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个 <code>worker</code> 都有一个工作队列，工作者线程处理自己工作队列中的所有工作。在实际的驱动开发中，只需要定义工作<code>(work_struct)</code>即可，关于工作队列和工作者线程基本不用去管。</p><ul><li><p>创建工作直接定一个<code>work_struct</code>结构体，然后使用<code>INIT_WORK</code>宏来初始化工作即可，<code>INIT_WORK</code>宏定义如下：</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* _work 表示要初始化的工作， _func 是工作对应的处理函数。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_WORK(_work, _func)</span></span><br></pre></td></tr></table></figure><p>也可以使用<code>DECLARE_WORK</code>宏一次性完成工作的创建和初始化，宏定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* n 表示定义的工作(work_struct)， f 表示工作对应的处理函数。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_WORK(n, f)</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>同<code>tasklet</code>一样，工作也是需要调度才能运行的，工作的调度函数为 <code>schedule_work</code>，函数原型如下所示：</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @brief 调度工作</span></span><br><span class="line"><span class="comment">* @param work 要调度的工作</span></span><br><span class="line"><span class="comment">* @return 结果 0 成功，其他值 失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">schedule_work</span><span class="params">(struct work_struct *work)</span></span></span><br></pre></td></tr></table></figure></blockquote></li></ul><hr><p><strong>工作队列使用顺序：</strong></p><ol><li>定义一个<code>work</code>。</li><li>初始化<code>work</code>，重点同样是是设置对应的处理函数。</li><li>在上半部中调用<code>schedule_work</code>函数，使 <code>work</code> 在合适的时间运行。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义工作(work) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">testwork</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* work 处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testwork_func_t</span><span class="params">(struct work_struct *work)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 根据成员变量反推出结构体的首地址 */</span></span><br><span class="line">    <span class="comment">//struct demo_struct *p = container_of(work, struct demo_struct, 成员变量名);</span></span><br><span class="line"><span class="comment">/* work 具体处理内容 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">irqreturn_t</span> <span class="title">test_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 调度 work */</span></span><br><span class="line">    schedule_work(&amp;testwork);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动入口函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">xxxx_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 初始化 work */</span></span><br><span class="line">    INIT_WORK(&amp;testwork, <span class="keyword">testwork_func_t</span>);</span><br><span class="line">    <span class="comment">/* 注册中断处理函数 */</span></span><br><span class="line">    request_irq(xxx_irq, test_handler, <span class="number">0</span>, <span class="string">"xxx"</span>, &amp;xxx_dev);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-设备树中断节点信息"><a href="#1-4-设备树中断节点信息" class="headerlink" title="1.4 设备树中断节点信息"></a>1.4 设备树中断节点信息</h3><p><code>#interrupt-cells</code>指定中断域编码中断说明符所需的单元数。对于设备来说，会使用<code>interrupts</code>属性来描述中断信息，而<code>#interrupt-cells</code>则指定了描述一个中断信息需要几个数值。</p><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@<span class="number">00</span>a01000 &#123;</span><br><span class="line"> compatible = <span class="string">"arm,cortex-a7-gic"</span>;</span><br><span class="line"> <span class="meta">#interrupt-cells = <span class="meta-string">&lt;3&gt;;</span></span></span><br><span class="line"> interrupt-controller;</span><br><span class="line"> reg = &lt;<span class="number">0x00a01000</span> <span class="number">0x1000</span>&gt;,</span><br><span class="line"> &lt;<span class="number">0x00a02000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">gpio5: gpio@<span class="number">020</span>ac000 &#123;</span><br><span class="line"> compatible = <span class="string">"fsl,imx6ul-gpio"</span>, <span class="string">"fsl,imx35-gpio"</span>;</span><br><span class="line"> reg = &lt;<span class="number">0x020ac000</span> <span class="number">0x4000</span>&gt;;</span><br><span class="line"> <span class="built_in">interrupts</span> = &lt;GIC_SPI <span class="number">74</span> IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">  &lt;GIC_SPI <span class="number">75</span> IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line"> gpio-controller;</span><br><span class="line"> <span class="meta">#gpio-cells = <span class="meta-string">&lt;2&gt;;</span></span></span><br><span class="line"> interrupt-controller;<span class="comment">// 表示当前节点是中断控制器</span></span><br><span class="line"> <span class="meta">#interrupt-cells = <span class="meta-string">&lt;2&gt;;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从<code>gpio5</code>的<code>interrupts</code>属性可以看到描述一个中断信息需要三个<code>cell</code>，分别是</p><ul><li>第一个 <code>cell</code>：中断类型， <code>0</code> 表示 <code>SPI</code> 中断（共享中断，不是 <code>SPI</code>通讯的中断）， <code>1</code> 表示 <code>PPI</code> 中断。</li><li>第二个 <code>cell</code>：中断号，对于 <code>SPI</code> 中断来说中断号的范围为 <code>0~987</code>，对于 <code>PPI</code> 中断来说中断号的范围为 <code>0~15</code>。</li><li>第三个 <code>cell</code>：标志， <code>bit[3:0]</code>表示中断触发类型，为 <code>1</code> 的时候表示上升沿触发，为 <code>2</code> 的时候表示下降沿触发，为 <code>4</code> 的时候表示高电平触发，为 <code>8</code> 的时候表示低电平触发。<code>bit[15:8]</code>为 <code>PPI</code> 中断的 <code>CPU 掩码</code>。</li></ul></blockquote><hr><p>在NXP的官方<code>6ull</code>开发板上有一个磁力计芯片<code>fxls8471</code>，<code>fxls8471</code>的中断引脚链接到<code>I.MX6ULL</code>的<code>SNVS_TAMPER0</code>引脚上，而这个引脚可以复用为<code>GPIO_IO0</code>。在设备树中<code>fxls8471</code>的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fxls8471@<span class="number">1</span>e &#123;</span><br><span class="line">    compatible = <span class="string">"fsl,fxls8471"</span>;</span><br><span class="line">    reg = &lt;<span class="number">0x1e</span>&gt;;</span><br><span class="line">    <span class="built_in">position</span> = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpio5&gt;;</span><br><span class="line">    <span class="built_in">interrupts</span> = &lt;<span class="number">0</span> <span class="number">8</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>interrupt-parent</code> 属性设置中断控制器，这里使用 <code>gpio5</code> 作为中断控制器。</li><li><code>interrupts</code> 属性设置中断信息，因为在上面 <code>gpio5</code> 的节点中将 <code>#interrupt-cells</code> 设置为了<code>2</code>，所以这里的 <code>interrupts</code> 属性，需要使用两个 <code>cell</code> 来描述中断信息。</li></ul><hr><p>从设备树中获取中断号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @brief 获取中断号</span></span><br><span class="line"><span class="comment"> * @param dev 设备节点</span></span><br><span class="line"><span class="comment"> * @param index 索引号</span></span><br><span class="line"><span class="comment"> * @return 中断号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">irq_of_parse_and_map</span><span class="params">(struct device_node *dev, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure><p>如果使用 <code>GPIO</code> 的话，可以使用 <code>gpio_to_irq</code> 函数来获取 <code>gpio</code> 对应的中断号，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @brief 获取gpio对应的中断号</span></span><br><span class="line"><span class="comment"> * @param gpio 要获取的GPIO编号</span></span><br><span class="line"><span class="comment"> * @return GPIO对应的中断号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gpio_to_irq</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> gpio)</span></span></span><br></pre></td></tr></table></figure><h2 id="二、编写按键中断实验驱动"><a href="#二、编写按键中断实验驱动" class="headerlink" title="二、编写按键中断实验驱动"></a>二、编写按键中断实验驱动</h2><h3 id="2-1-配置设备树"><a href="#2-1-配置设备树" class="headerlink" title="2.1 配置设备树"></a>2.1 配置设备树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dt-bindings/input/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"imx6ull.dtsi"</span></span></span><br><span class="line"></span><br><span class="line">/ &#123;</span><br><span class="line">model = <span class="string">"Freescale i.MX6 ULL 14x14 EVK Board"</span>;</span><br><span class="line">compatible = <span class="string">"fsl,imx6ull-14x14-evk"</span>, <span class="string">"fsl,imx6ull"</span>;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自己添加的节点 2020-9-17 */</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">key &#123;</span><br><span class="line">compatible = <span class="string">"atkalpha,key"</span>;</span><br><span class="line">pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_key&gt;;</span><br><span class="line">key-gpios = &lt;&amp;gpio1 <span class="number">18</span> GPIO_ACTIVE_HIGH&gt;;</span><br><span class="line">status = <span class="string">"okay"</span>;</span><br><span class="line">interrupt-parent = &lt;&amp;gpio1&gt;;</span><br><span class="line"><span class="built_in">interrupts</span> = &lt;<span class="number">18</span> IRQ_TYPE_EDGE_BOTH&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">&amp;iomuxc &#123;</span><br><span class="line">pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">imx6ul-evk &#123;</span><br><span class="line">pinctrl_hog_1: hoggrp<span class="number">-1</span> &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19<span class="number">0x17059</span> <span class="comment">/* SD1 CD */</span></span><br><span class="line">MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT<span class="number">0x17059</span> <span class="comment">/* SD1 VSELECT */</span></span><br><span class="line">MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        <span class="number">0x17059</span> <span class="comment">/* SD1 RESET */</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自己定义的IO复用 START */</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">pinctrl_key: keygrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART1_CTS_B__GPIO1_IO18<span class="number">0XF080</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自己定义的IO复用 END */</span></span><br><span class="line"></span><br><span class="line">……</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure><h3 id="2-2-按键中断驱动程序"><a href="#2-2-按键中断驱动程序" class="headerlink" title="2.2 按键中断驱动程序"></a>2.2 按键中断驱动程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_NAME<span class="meta-string">"keyirq"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_NUM1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_VALUE0X01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVAKEY0XFF<span class="comment">/* 无效按键值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> gpio;<span class="comment">/* IO编号 */</span></span><br><span class="line"><span class="keyword">int</span> irqNum;<span class="comment">/* 中断号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> value;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">/* 名称 */</span></span><br><span class="line"><span class="keyword">irqreturn_t</span> (*handler)(<span class="keyword">int</span>, <span class="keyword">void</span>*);<span class="comment">/* 中断处理函数 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义设备驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">/* 设备ID */</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="keyword">int</span> minor;<span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* 字符设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">/* 设备类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span> <span class="title">key</span>[<span class="title">KEY_NUM</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定时器 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> keyValue;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">atomic_t</span> keyRelease;<span class="comment">/* 按键是否释放 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> <span class="title">keyirq</span>;</span><span class="comment">/* 定义一个keyirq设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;keyirq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyValue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyRelease;</span><br><span class="line"></span><br><span class="line">keyValue = atomic_read(&amp;dev-&gt;keyValue);</span><br><span class="line">keyRelease = atomic_read(&amp;dev-&gt;keyRelease);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyRelease)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 一次有效按键 */</span></span><br><span class="line"><span class="keyword">if</span> (keyValue &amp; <span class="number">0X80</span>)</span><br><span class="line">&#123;</span><br><span class="line">keyValue &amp;= ~<span class="number">0X80</span>;<span class="comment">// 去除标记</span></span><br><span class="line">ret = copy_to_user(buf, &amp;keyValue, <span class="keyword">sizeof</span>(keyValue));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">data_err:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">keyirq_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = keyirq_open,</span><br><span class="line">.<span class="built_in">release</span> = keyirq_release,</span><br><span class="line">.<span class="built_in">write</span> = keyirq_write,</span><br><span class="line">.<span class="built_in">read</span> = keyirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 用户参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">value = gpio_get_value(dev-&gt;key[<span class="number">0</span>].gpio);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键按下</span></span><br><span class="line">printk(<span class="string">"KEY0 Press!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键释放</span></span><br><span class="line">printk(<span class="string">"KEY0 Release!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value | <span class="number">0X80</span>);<span class="comment">// 打上标签，标记按键按下</span></span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键中断处理函数</span></span><br><span class="line"><span class="comment"> * @param irq 中断号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">key0_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器来延时消抖 */</span></span><br><span class="line">dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键初始化</span></span><br><span class="line"><span class="comment"> * @param dev 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 错误类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyio_init</span><span class="params">(struct keyirq_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键初始化 */</span></span><br><span class="line">dev-&gt;nd = of_find_node_by_path(<span class="string">"/key"</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_nd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可能有多个按键，因此需要根据实际数量来读取 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;key[i].gpio = of_get_named_gpio(dev-&gt;nd, <span class="string">"key-gpios"</span>, i);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;key[i].gpio &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_getGpio;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dev-&gt;key[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;key[i].name));</span><br><span class="line"><span class="built_in">sprintf</span>(dev-&gt;key[i].name, <span class="string">"KEY%d"</span>, i);</span><br><span class="line">ret = gpio_request(dev-&gt;key[i].gpio, dev-&gt;key[i].name);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_requestGpio;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_input(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setGpioDir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取中断号 */</span></span><br><span class="line">dev-&gt;key[i].irqNum = gpio_to_irq(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="comment">// dev-&gt;key[i].irqNum = irq_of_parse_and_map(dev-&gt;nd, i);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键中断初始化 */</span></span><br><span class="line">dev-&gt;key[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">dev-&gt;key[<span class="number">0</span>].value = KEY0_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 跳变沿触发方式 */</span></span><br><span class="line">ret = request_irq(dev-&gt;key[i].irqNum, dev-&gt;key[i].handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, dev-&gt;key[i].name, dev);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"irq %d request failed!\r\n"</span>, dev-&gt;key[i].irqNum);</span><br><span class="line"><span class="keyword">goto</span> fail_irq;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化定时器 */</span></span><br><span class="line">init_timer(&amp;dev-&gt;timer);</span><br><span class="line">dev-&gt;timer.function = timer_func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_irq:</span><br><span class="line">fail_setGpioDir:</span><br><span class="line"><span class="keyword">for</span> (i = i<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">gpio_free(dev-&gt;key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line">fail_requestGpio:</span><br><span class="line">fail_getGpio:</span><br><span class="line">fail_nd:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">keyirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备ID */</span></span><br><span class="line">keyirq.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(keyirq.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">keyirq.devid = MKDEV(keyirq.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(keyirq.devid, KEYIRQ_CNT, KEYIRQ_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;keyirq.devid, <span class="number">0</span>,KEYIRQ_CNT,KEYIRQ_NAME);</span><br><span class="line">keyirq.major = MAJOR(keyirq.devid);</span><br><span class="line">keyirq.minor = MINOR(keyirq.devid);</span><br><span class="line">printk(<span class="string">"dev Major ID:%d\r\n"</span>,keyirq.major);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化字符设备 */</span></span><br><span class="line">keyirq.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;keyirq.cdev, &amp;keyirq_fops);</span><br><span class="line">ret = cdev_add(&amp;keyirq.cdev, keyirq.devid, KEYIRQ_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备类 */</span></span><br><span class="line">keyirq<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">KEYIRQ_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">keyirq.device = device_create(keyirq.class, <span class="literal">NULL</span>, keyirq.devid, <span class="literal">NULL</span>, KEYIRQ_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化IO */</span></span><br><span class="line">ret = keyio_init(&amp;keyirq);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">atomic_set(&amp;keyirq.keyValue, INVAKEY);</span><br><span class="line">atomic_set(&amp;keyirq.keyRelease, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_init:</span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(keyirq.devid, KEYIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">keyirq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 释放中断和IO */</span></span><br><span class="line">free_irq(keyirq.key[i].irqNum, &amp;keyirq);</span><br><span class="line">gpio_free(keyirq.key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除定时器 */</span></span><br><span class="line">del_timer_sync(&amp;keyirq.timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">unregister_chrdev_region(keyirq.devid,KEYIRQ_CNT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(keyirq_init);</span><br><span class="line">module_exit(keyirq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3-使用下半部tasklet的按键中断驱动程序"><a href="#2-3-使用下半部tasklet的按键中断驱动程序" class="headerlink" title="2.3 使用下半部tasklet的按键中断驱动程序"></a>2.3 使用下半部<code>tasklet</code>的按键中断驱动程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/interrupt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEYIRQ_NAME<span class="meta-string">"keyirq"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY_NUM1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KEY0_VALUE0X01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INVAKEY0XFF<span class="comment">/* 无效按键值 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> gpio;<span class="comment">/* IO编号 */</span></span><br><span class="line"><span class="keyword">int</span> irqNum;<span class="comment">/* 中断号 */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> value;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">/* 名称 */</span></span><br><span class="line"><span class="keyword">irqreturn_t</span> (*handler)(<span class="keyword">int</span>, <span class="keyword">void</span>*);<span class="comment">/* 中断处理函数 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">tasklet</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义设备驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">/* 设备ID */</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="keyword">int</span> minor;<span class="comment">/* 次设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* 字符设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">/* 设备类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备树节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key_dev</span> <span class="title">key</span>[<span class="title">KEY_NUM</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定时器 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> keyValue;<span class="comment">/* 按键值 */</span></span><br><span class="line"><span class="keyword">atomic_t</span> keyRelease;<span class="comment">/* 按键是否释放 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> <span class="title">keyirq</span>;</span><span class="comment">/* 定义一个keyirq设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;keyirq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyirq_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">keyirq_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyValue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> keyRelease;</span><br><span class="line"></span><br><span class="line">keyValue = atomic_read(&amp;dev-&gt;keyValue);</span><br><span class="line">keyRelease = atomic_read(&amp;dev-&gt;keyRelease);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (keyRelease)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 一次有效按键 */</span></span><br><span class="line"><span class="keyword">if</span> (keyValue &amp; <span class="number">0X80</span>)</span><br><span class="line">&#123;</span><br><span class="line">keyValue &amp;= ~<span class="number">0X80</span>;<span class="comment">// 去除标记</span></span><br><span class="line">ret = copy_to_user(buf, &amp;keyValue, <span class="keyword">sizeof</span>(keyValue));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">0</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> data_err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">data_err:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作集 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">keyirq_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = keyirq_open,</span><br><span class="line">.<span class="built_in">release</span> = keyirq_release,</span><br><span class="line">.<span class="built_in">write</span> = keyirq_write,</span><br><span class="line">.<span class="built_in">read</span> = keyirq_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 用户参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_func</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span>*)<span class="title">arg</span>;</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">value = gpio_get_value(dev-&gt;key[<span class="number">0</span>].gpio);</span><br><span class="line"><span class="keyword">if</span> (value == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键按下</span></span><br><span class="line">printk(<span class="string">"KEY0 Press!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(value == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 按键释放</span></span><br><span class="line">printk(<span class="string">"KEY0 Release!\r\n"</span>);</span><br><span class="line">atomic_set(&amp;dev-&gt;keyValue, dev-&gt;key[<span class="number">0</span>].value | <span class="number">0X80</span>);<span class="comment">// 打上标签，标记按键按下</span></span><br><span class="line">atomic_set(&amp;dev-&gt;keyRelease, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief key0 tasklet 处理函数</span></span><br><span class="line"><span class="comment"> * @param arg 传递的参数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">key0_tasklet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = (<span class="title">struct</span> <span class="title">keyirq_dev</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器来延时消抖 */</span></span><br><span class="line">dev-&gt;timer.data = (<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>)arg;</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(<span class="number">20</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键中断处理函数</span></span><br><span class="line"><span class="comment"> * @param irq 中断号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">key0_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">keyirq_dev</span> *<span class="title">dev</span> = <span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">tasklet_schedule(&amp;dev-&gt;key[<span class="number">0</span>].tasklet);<span class="comment">/* 调度对应的tasklet */</span></span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 按键初始化</span></span><br><span class="line"><span class="comment"> * @param dev 设备结构体</span></span><br><span class="line"><span class="comment"> * @return 错误类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">keyio_init</span><span class="params">(struct keyirq_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键初始化 */</span></span><br><span class="line">dev-&gt;nd = of_find_node_by_path(<span class="string">"/key"</span>);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_nd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 可能有多个按键，因此需要根据实际数量来读取 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line">dev-&gt;key[i].gpio = of_get_named_gpio(dev-&gt;nd, <span class="string">"key-gpios"</span>, i);</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;key[i].gpio &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_getGpio;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dev-&gt;key[i].name, <span class="number">0</span>, <span class="keyword">sizeof</span>(dev-&gt;key[i].name));</span><br><span class="line"><span class="built_in">sprintf</span>(dev-&gt;key[i].name, <span class="string">"KEY%d"</span>, i);</span><br><span class="line">ret = gpio_request(dev-&gt;key[i].gpio, dev-&gt;key[i].name);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_requestGpio;</span><br><span class="line">&#125;</span><br><span class="line">ret = gpio_direction_input(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setGpioDir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取中断号，两种方式皆可 */</span></span><br><span class="line">dev-&gt;key[i].irqNum = gpio_to_irq(dev-&gt;key[i].gpio);</span><br><span class="line"><span class="comment">// dev-&gt;key[i].irqNum = irq_of_parse_and_map(dev-&gt;nd, i);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按键中断初始化 */</span></span><br><span class="line">dev-&gt;key[<span class="number">0</span>].handler = key0_handler;</span><br><span class="line">dev-&gt;key[<span class="number">0</span>].value = KEY0_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 跳变沿触发方式 */</span></span><br><span class="line">ret = request_irq(dev-&gt;key[i].irqNum, dev-&gt;key[i].handler, IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING, dev-&gt;key[i].name, dev);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"irq %d request failed!\r\n"</span>, dev-&gt;key[i].irqNum);</span><br><span class="line"><span class="keyword">goto</span> fail_irq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>没有根据多个按键来初始化各自的tasklet,实际中需要根据情况来编写 */</span></span><br><span class="line">tasklet_init(&amp;dev-&gt;key[i].tasklet, key0_tasklet, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化定时器 */</span></span><br><span class="line">init_timer(&amp;dev-&gt;timer);</span><br><span class="line">dev-&gt;timer.function = timer_func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_irq:</span><br><span class="line">fail_setGpioDir:</span><br><span class="line"><span class="keyword">for</span> (i = i<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">gpio_free(dev-&gt;key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line">fail_requestGpio:</span><br><span class="line">fail_getGpio:</span><br><span class="line">fail_nd:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">keyirq_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备ID */</span></span><br><span class="line">keyirq.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(keyirq.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">keyirq.devid = MKDEV(keyirq.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(keyirq.devid, KEYIRQ_CNT, KEYIRQ_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;keyirq.devid, <span class="number">0</span>,KEYIRQ_CNT,KEYIRQ_NAME);</span><br><span class="line">keyirq.major = MAJOR(keyirq.devid);</span><br><span class="line">keyirq.minor = MINOR(keyirq.devid);</span><br><span class="line">printk(<span class="string">"dev Major ID:%d\r\n"</span>,keyirq.major);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化字符设备 */</span></span><br><span class="line">keyirq.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;keyirq.cdev, &amp;keyirq_fops);</span><br><span class="line">ret = cdev_add(&amp;keyirq.cdev, keyirq.devid, KEYIRQ_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备类 */</span></span><br><span class="line">keyirq<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">KEYIRQ_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">keyirq.device = device_create(keyirq.class, <span class="literal">NULL</span>, keyirq.devid, <span class="literal">NULL</span>, KEYIRQ_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(keyirq.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(keyirq.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化IO */</span></span><br><span class="line">ret = keyio_init(&amp;keyirq);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_init;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化原子变量 */</span></span><br><span class="line">atomic_set(&amp;keyirq.keyValue, INVAKEY);</span><br><span class="line">atomic_set(&amp;keyirq.keyRelease, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_init:</span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(keyirq.devid, KEYIRQ_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">keyirq_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; KEY_NUM; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 释放中断和IO */</span></span><br><span class="line">free_irq(keyirq.key[i].irqNum, &amp;keyirq);</span><br><span class="line">gpio_free(keyirq.key[i].gpio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除定时器 */</span></span><br><span class="line">del_timer_sync(&amp;keyirq.timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备驱动 */</span></span><br><span class="line">device_destroy(keyirq.class, keyirq.devid);</span><br><span class="line">class_destroy(keyirq.class);</span><br><span class="line">cdev_del(&amp;keyirq.cdev);</span><br><span class="line">unregister_chrdev_region(keyirq.devid,KEYIRQ_CNT);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(keyirq_init);</span><br><span class="line">module_exit(keyirq_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><h3 id="2-4-测试APP程序"><a href="#2-4-测试APP程序" class="headerlink" title="2.4 测试APP程序"></a>2.4 测试APP程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ./keyReadAPP /dev/keyirq</span></span><br><span class="line"><span class="comment"> * @param argc 应用程序参数个数</span></span><br><span class="line"><span class="comment"> * @param argv 保存的参数，字符串形式。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (argc != 3)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("输入错误\r\n");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: Open %s fail.\r\n"</span>,filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 循环读取 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = <span class="built_in">read</span>(fd, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"keyValue = %#x\r\n"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 */</span></span><br><span class="line">ret = <span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: Close %s fail.\r\n"</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（八）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89.html</id>
    <published>2020-11-17T14:51:31.000Z</published>
    <updated>2020-12-19T14:25:46.855Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h1 id="Linux内核定时器和ioctl函数"><a href="#Linux内核定时器和ioctl函数" class="headerlink" title="Linux内核定时器和ioctl函数"></a>Linux内核定时器和ioctl函数</h1><ol><li><p>内核时间管理</p><p>1.1 对于<code>Cortex-M</code>内核来说，一般使用<code>systick</code>硬件定时器作为系统定时器，使用过<code>FreeRTOS</code>等操作系统的也知道，<code>FreeRTOS</code>一般就是使用<code>systick</code>来提供系统时钟，同样<code>Linux</code>也需要系统时钟。</p><p>1.2 <code>Linux</code>内核频率可以配置，在图形化界面可以配置。在<code>include/aasm-generic/param.h</code>文件中可以看到内核配置的节拍率<code>HZ</code>（系统频率）。</p><p>1.3 <code>HZ</code>表示每秒的节拍数。</p><a id="more"></a></li><li><p>节拍率高低的缺陷</p><p>系统使用硬件定时中断来计时，中断周期性产生的频率就是系统频率，也叫作节拍率<code>tick rate</code>。</p><p>节拍率越高，时间精度越高，同样也会加剧系统的负担。</p></li><li><p><code>jiffies</code></p><p><code>Linux</code>内核使用全局变量<code>jiffies</code>来记录系统从启动以来的系统节拍数，系统启动的时候会将其初始化为0，<code>jiffies</code>定义在文件<code>include/linux/jiffies.h</code>中。<code>jiffies</code>/<code>HZ</code>就是系统运行时间，单位为秒。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************** 判断是否超时的api函数  ***************/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* unkown 通常为 jiffies， known 通常是需要对比的值。 */</span></span><br><span class="line">time_after(unkown, known)</span><br><span class="line">time_before(unkown, known) </span><br><span class="line">time_after_eq(unkown, known)</span><br><span class="line">time_before_eq(unkown, known)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/************** jiffies 和 ms、us、ns的转化函数  ***************/</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 jiffies 类型的参数 j 分别转换为对应的毫秒、微秒、纳秒。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jiffies_to_msecs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> j)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jiffies_to_usecs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> j)</span> </span></span><br><span class="line"><span class="function">u64 <span class="title">jiffies_to_nsecs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> j)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 将毫秒、微秒、纳秒转换为 jiffies 类型。 */</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">msecs_to_jiffies</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">usecs_to_jiffies</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> u)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">nsecs_to_jiffies</span><span class="params">(u64 n)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/***************** 使用 jiffies 判断超时 ****************/</span> </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> timeout</span>;</span><br><span class="line">timeout = jiffies + (<span class="number">2</span> * HZ); <span class="comment">/* 超时的时间点 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断有没有超时 */</span></span><br><span class="line"><span class="keyword">if</span>(time_before(jiffies, timeout)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 超时未发生 */</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 超时发生 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>内核定时器</p><p>4.1 软件定时器不像硬件定时器一样是直接设置周期值的。软件定时器是设置期限满以后的时间点。</p><p>4.2 需要编写定时器处理函数。</p><p>4.3 内核定时器不是周期性的，一次定时时间到了以后就会关闭，除非重新打开。</p></li><li><p>定时器<code>API</code>函数</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******** timer_list 结构体 **********/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires; <span class="comment">/* 定时器超时时间，单位是节拍数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_base</span>* <span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">void</span> (*function)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);<span class="comment">/* 定时处理函数 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data; <span class="comment">/* 要传递给 function 函数的参数 */</span></span><br><span class="line">    <span class="keyword">int</span> slack;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************ api函数 ************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_timer</span><span class="params">(struct timer_list* timer)</span></span>;<span class="comment">// 初始化定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(struct timer_list* timer)</span></span>;<span class="comment">// 向Linux内核注册定时器，同时启动定时器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer</span><span class="params">(struct timer_list* timer)</span></span>;<span class="comment">// 删除一个定时器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del_timer_sync</span><span class="params">(struct timer_list* timer)</span></span>;<span class="comment">// del_timer 函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync 不能使用在中断上下文中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod_timer</span><span class="params">(struct timer_list* timer, <span class="keyword">unsigned</span> <span class="keyword">long</span> expires)</span></span>;<span class="comment">// 修改定时值，同时启动定时器</span></span><br></pre></td></tr></table></figure><ol start="6"><li>内核短延时函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ndelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> nsecs)</span></span>;<span class="comment">// 纳秒延时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">udelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> usecs)</span></span>;<span class="comment">// 微秒延时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mdelay</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> mseces)</span></span>;<span class="comment">// 毫秒延时</span></span><br></pre></td></tr></table></figure><h1 id="定时器使用练手"><a href="#定时器使用练手" class="headerlink" title="定时器使用练手"></a>定时器使用练手</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_NAME<span class="meta-string">"timer"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDOFF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDON 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义设备驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;</span><br><span class="line"><span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="keyword">int</span> led_gpio;<span class="comment">/* led 所使用的 GPIO 编号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器 */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span> <span class="title">timerdev</span>;</span><span class="comment">/* 定义一个设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;timerdev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">led_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = copy_from_user(databuff, buf, count);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"kernel write failed!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(databuff[<span class="number">0</span>] == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = led_open,</span><br><span class="line">.<span class="built_in">release</span> = led_release,</span><br><span class="line">.<span class="built_in">write</span> = led_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">mod_timer(&amp;timerdev.timer, jiffies + msecs_to_jiffies(<span class="number">500</span>));<span class="comment">// 修改时间点，并重新开启定时器。</span></span><br><span class="line">gpio_set_value(timerdev.led_gpio, i);</span><br><span class="line">i = !i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备ID */</span></span><br><span class="line">timerdev.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(timerdev.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">timerdev.devid = MKDEV(timerdev.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(timerdev.devid, TIMER_CNT, TIMER_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;timerdev.devid, <span class="number">0</span>,TIMER_CNT,TIMER_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化字符设备 */</span></span><br><span class="line">timerdev.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;timerdev.cdev, &amp;led_fops);</span><br><span class="line">ret = cdev_add(&amp;timerdev.cdev, timerdev.devid, TIMER_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建类 */</span></span><br><span class="line">timerdev<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">TIMER_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(timerdev.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(timerdev.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">timerdev.device = device_create(timerdev.class, <span class="literal">NULL</span>, timerdev.devid, <span class="literal">NULL</span>, TIMER_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(timerdev.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(timerdev.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取设备节点 */</span></span><br><span class="line">timerdev.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line"><span class="keyword">if</span> (timerdev.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取LED对应的GPIO */</span></span><br><span class="line">timerdev.led_gpio = of_get_named_gpio(timerdev.nd, <span class="string">"led-gpios"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (timerdev.led_gpio &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 申请IO */</span></span><br><span class="line">ret = gpio_request(timerdev.led_gpio, <span class="string">"led_gpio"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"failed to request the led\r\n"</span>);</span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>申请失败的话，大部分原因这个IO被别的外设占用</span></span><br><span class="line"><span class="comment"> * 需要在设备树中屏蔽相关代码，或者status属性值设置为disable</span></span><br><span class="line"><span class="comment"> * 检查复用，也就是pinctl</span></span><br><span class="line"><span class="comment"> * gpio使用 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用IO 设置为输出 默认为低电平*/</span></span><br><span class="line">ret = gpio_direction_output(timerdev.led_gpio, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setoutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_timer(&amp;timerdev.timer);<span class="comment">// 初始化定时器</span></span><br><span class="line">timerdev.timer.function = timer_function;</span><br><span class="line">timerdev.timer.expires = jiffies + msecs_to_jiffies(<span class="number">500</span>);<span class="comment">// 两秒</span></span><br><span class="line">add_timer(&amp;timerdev.timer);<span class="comment">// 添加到系统</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_setoutput:</span><br><span class="line">gpio_free(timerdev.led_gpio);</span><br><span class="line">fail_findnd:</span><br><span class="line">device_destroy(timerdev.class, timerdev.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(timerdev.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;timerdev.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(timerdev.devid, TIMER_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">timer_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 释放IO */</span></span><br><span class="line">gpio_free(timerdev.led_gpio);</span><br><span class="line">device_destroy(timerdev.class, timerdev.devid);</span><br><span class="line">class_destroy(timerdev.class);</span><br><span class="line">cdev_del(&amp;timerdev.cdev);</span><br><span class="line">unregister_chrdev_region(timerdev.devid,TIMER_CNT);</span><br><span class="line">del_timer(&amp;timerdev.timer);<span class="comment">// 删除定时器</span></span><br><span class="line">gpio_set_value(timerdev.led_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><h1 id="使用ioctl函数控制"><a href="#使用ioctl函数控制" class="headerlink" title="使用ioctl函数控制"></a>使用<code>ioctl</code>函数控制</h1><p>用户<code>APP</code>中使用<code>ioctl</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlocked_ioctl();</span><br><span class="line">compat_ioctl();</span><br></pre></td></tr></table></figure><p>对应驱动里的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果是64位的应用程序运行在64位的内核上，调用的是unlocked_ioctl，</span></span><br><span class="line"><span class="comment"> * 如果是32位的应用程序运行在32位的内核上，调用的也是unlocked_ioctl。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> (*unlocked_ioctl)(struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 支持64位系统的驱动必须要实现的ioctl，当有32位的应用程序调用64位内核的ioctl时，</span></span><br><span class="line"><span class="comment"> * 这个回调函数会被调用，如果没有实现compat_ioctl，那么32位的应用程序在64位的内核上</span></span><br><span class="line"><span class="comment"> * 执行ioctl时会返回错误：Not a typewriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">long</span> (*compat_ioctl)(struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br></pre></td></tr></table></figure><p><code>ioctl</code>的命令是自己定义的，但是要符合<code>Linux</code>的<strong>规则</strong>。具体的说明可以查看博主<a href="https://blog.csdn.net/coolwriter" target="_blank" rel="noopener">coolwriter</a>的博客。</p><p><code>cmd</code>拆分如下</p><table><thead><tr><th align="center">幻数(type)</th><th align="center">序数(number)</th><th align="center">数据传输方向(direction)</th><th align="center">数据大小(size)</th></tr></thead><tbody><tr><td align="center">8bit</td><td align="center">8bit</td><td align="center">2bit</td><td align="center">14bit</td></tr></tbody></table><ul><li>幻数：是一个<code>0~0xFF</code>的数，是用来区分不同的书驱动的。</li><li>序数：用这个数来给自己的命令编号。</li><li>数据传输方向：如果涉及到要传参，内核要求描述一下传输的方向。<ul><li><code>_IOC_NONE</code>：值为0，无数据传输。</li><li><code>_IOC_READ</code>：值为1，从设备驱动读取数据。</li><li><code>_IOC_WRITE</code>：值为2，向设备驱动写入数据。</li><li><code>_IOC_READ|_IOC_WRITE</code>：双向数据传输。</li></ul></li><li>数据大小：==与体系结构相关==，<code>ARM</code>下占<code>14bit(_IOC_SIZEBITS)</code>，如果数据是<code>int</code>，内核给这个赋的值就是<code>sizeof(int)</code>。</li></ul><p>构建命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* type是幻数，nr是序数，size是大小 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO(type, nr)<span class="comment">// 没有参数的命令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOR(type, nr, size)<span class="comment">// 该命令是从驱动读取数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOW(type, nr, size)<span class="comment">// 该命令是从驱动写入数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IOWR(type, nr, size)<span class="comment">// 双向数据传输</span></span></span><br></pre></td></tr></table></figure><p>驱动程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_NAME<span class="meta-string">"timer"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 构建命令</span></span><br><span class="line"><span class="comment"> * 0xEF是在Linux内核文档中找的没用被其他驱动程序占用的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE_CMD_IO(0xEF, 1)<span class="comment">// 关闭命令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_CMD_IO(0xEF, 2)<span class="comment">// 打开命令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_PERIOD_CMD_IOW(0xEF, 3, int)<span class="comment">// 设置周期</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义设备驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;</span><br><span class="line"><span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="keyword">int</span> led_gpio;<span class="comment">/* led 所使用的 GPIO 编号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span><span class="comment">/* 定义一个定时器 */</span></span><br><span class="line"><span class="keyword">atomic_t</span> timePeriod;<span class="comment">/* 定时器时间周期，使用原子变量，保护数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span> <span class="title">timerdev</span>;</span><span class="comment">/* 定义一个设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timer_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;timerdev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timer_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">timer_ioctl</span><span class="params">(struct file* filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> CLOSE_CMD:</span><br><span class="line"><span class="comment">/* 关闭定时器 */</span></span><br><span class="line">del_timer_sync(&amp;dev-&gt;timer);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> OPEN_CMD:</span><br><span class="line"><span class="comment">/* 设置时间点 */</span></span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(atomic_read(&amp;dev-&gt;timePeriod)));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SET_PERIOD_CMD:</span><br><span class="line"><span class="comment">/* 根据APP程序设置的周期来设置定时器的时间点 */</span></span><br><span class="line">ret = copy_from_user(&amp;value, (<span class="keyword">int</span> *)arg, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line">atomic_set(&amp;dev-&gt;timePeriod, value);</span><br><span class="line">mod_timer(&amp;dev-&gt;timer, jiffies + msecs_to_jiffies(atomic_read(&amp;dev-&gt;timePeriod)));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">timer_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = timer_open,</span><br><span class="line">.<span class="built_in">release</span> = timer_release,</span><br><span class="line">.unlocked_ioctl = timer_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定时器处理函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timer_function</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 修改时间点，并重新开启定时器。 */</span></span><br><span class="line">mod_timer(&amp;timerdev.timer, jiffies + msecs_to_jiffies(atomic_read(&amp;timerdev.timePeriod)));</span><br><span class="line">gpio_set_value(timerdev.led_gpio, i);</span><br><span class="line">i = !i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">timer_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备ID */</span></span><br><span class="line">timerdev.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(timerdev.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">timerdev.devid = MKDEV(timerdev.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(timerdev.devid, TIMER_CNT, TIMER_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;timerdev.devid, <span class="number">0</span>,TIMER_CNT,TIMER_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化字符设备 */</span></span><br><span class="line">timerdev.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;timerdev.cdev, &amp;timer_fops);</span><br><span class="line">ret = cdev_add(&amp;timerdev.cdev, timerdev.devid, TIMER_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建类 */</span></span><br><span class="line">timerdev<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">TIMER_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(timerdev.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(timerdev.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建设备 */</span></span><br><span class="line">timerdev.device = device_create(timerdev.class, <span class="literal">NULL</span>, timerdev.devid, <span class="literal">NULL</span>, TIMER_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(timerdev.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(timerdev.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取设备节点 */</span></span><br><span class="line">timerdev.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line"><span class="keyword">if</span> (timerdev.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取LED对应的GPIO */</span></span><br><span class="line">timerdev.led_gpio = of_get_named_gpio(timerdev.nd, <span class="string">"led-gpios"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (timerdev.led_gpio &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 申请IO */</span></span><br><span class="line">ret = gpio_request(timerdev.led_gpio, <span class="string">"led_gpio"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"failed to request the led\r\n"</span>);</span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>申请失败的话，大部分原因这个IO被别的外设占用</span></span><br><span class="line"><span class="comment"> * 需要在设备树中屏蔽相关代码，或者status属性值设置为disable</span></span><br><span class="line"><span class="comment"> * 检查复用，也就是pinctl</span></span><br><span class="line"><span class="comment"> * gpio使用 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用IO 设置为输出 默认为低电平*/</span></span><br><span class="line">ret = gpio_direction_output(timerdev.led_gpio, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setoutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_timer(&amp;timerdev.timer);<span class="comment">// 初始化定时器</span></span><br><span class="line">atomic_set(&amp;timerdev.timePeriod, <span class="number">500</span>);<span class="comment">// 设置初始周期值</span></span><br><span class="line">timerdev.timer.function = timer_function;</span><br><span class="line">timerdev.timer.expires = jiffies + msecs_to_jiffies(atomic_read(&amp;timerdev.timePeriod));<span class="comment">// 500ms</span></span><br><span class="line">add_timer(&amp;timerdev.timer);<span class="comment">// 添加到系统</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_setoutput:</span><br><span class="line">gpio_free(timerdev.led_gpio);</span><br><span class="line">fail_findnd:</span><br><span class="line">device_destroy(timerdev.class, timerdev.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(timerdev.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;timerdev.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(timerdev.devid, TIMER_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">timer_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 释放IO */</span></span><br><span class="line">gpio_free(timerdev.led_gpio);</span><br><span class="line">device_destroy(timerdev.class, timerdev.devid);</span><br><span class="line">class_destroy(timerdev.class);</span><br><span class="line">cdev_del(&amp;timerdev.cdev);</span><br><span class="line">unregister_chrdev_region(timerdev.devid,TIMER_CNT);</span><br><span class="line">del_timer(&amp;timerdev.timer);<span class="comment">// 删除定时器</span></span><br><span class="line">gpio_set_value(timerdev.led_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(timer_init);</span><br><span class="line">module_exit(timer_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><p>测试APP程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 驱动里定义的命令 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE_CMD_IO(0xEF, 1)<span class="comment">// 关闭命令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_CMD_IO(0xEF, 2)<span class="comment">// 打开命令</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_PERIOD_CMD_IOW(0xEF, 3, int)<span class="comment">// 设置周期</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ./timerAPP &lt;filename&gt; &lt;0:1&gt;</span></span><br><span class="line"><span class="comment"> * @param argc 应用程序参数个数</span></span><br><span class="line"><span class="comment"> * @param argv 保存的参数，字符串形式。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cmd;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (argc != 3)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("输入错误\r\n");</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: Open %s fail.\r\n"</span>,filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入命令(1:关闭定时器，2:打开定时器，3:设置周期，4:关闭文件):"</span>);</span><br><span class="line">ret = <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cmd);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);<span class="comment">// 清空输入缓存，防止下次scanf时读取到上次遗留下的回车\n。</span></span><br><span class="line"><span class="keyword">if</span> (cmd == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ioctl(fd, CLOSE_CMD, <span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ioctl(fd, OPEN_CMD, <span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入定时器周期："</span>);</span><br><span class="line">ret = <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arg);</span><br><span class="line">fflush(<span class="built_in">stdin</span>);</span><br><span class="line">ioctl(fd, SET_PERIOD_CMD, &amp;arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 */</span></span><br><span class="line">ret = <span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: Close %s fail.\r\n"</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（七）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89.html</id>
    <published>2020-11-17T14:45:49.000Z</published>
    <updated>2020-12-18T15:04:27.135Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h1 id="Linux并发与竞争"><a href="#Linux并发与竞争" class="headerlink" title="Linux并发与竞争"></a>Linux并发与竞争</h1><h2 id="一、并发与竞争"><a href="#一、并发与竞争" class="headerlink" title="一、并发与竞争"></a>一、并发与竞争</h2><p>多线程对共享资源同时进行访问，比如全局变量，就会产生并发与竞争现象。以打印机为例，当线程A和线程B同时操作打印机时，就会出现竞争现象，如果没有处理就会导致数据错乱。</p><a id="more"></a><h2 id="二、原子操作atomic"><a href="#二、原子操作atomic" class="headerlink" title="二、原子操作atomic"></a>二、原子操作<code>atomic</code></h2><p>对整形变量或者位进行保护，确保对其进行操作时是最小操作，不会被干扰。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> counter;</span><br><span class="line">&#125; <span class="keyword">atomic_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">atomic_t</span> a = ATOMIC_INIT(<span class="number">0</span>);<span class="comment">// 定义原子变量a并赋初值为0；</span></span><br></pre></td></tr></table></figure><p>原子操作<code>API</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AIOMIC_INIT(<span class="keyword">int</span> i)<span class="comment">// 定义原子变量的时候对其初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_read</span><span class="params">(<span class="keyword">atomic_t</span>* v)</span><span class="comment">// 读取原子变量的值，并返回</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_set</span><span class="params">(<span class="keyword">atomic_t</span>* v, <span class="keyword">int</span> i)</span><span class="comment">// 给原子变量设置为i值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span>* v)</span><span class="comment">// 给原子变量加上i值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span>* v)</span><span class="comment">// 给原子变量减去i值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_inc</span><span class="params">(<span class="keyword">atomic_t</span>* v)</span><span class="comment">// 原子变量自增1</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">atomic_dec</span><span class="params">(<span class="keyword">atomic_t</span>* v)</span><span class="comment">// 原子变量自减1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_dec_return</span><span class="params">(<span class="keyword">atomic_t</span>* v)</span><span class="comment">// 原子变量减1，并且返回v的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_inc_return</span><span class="params">(<span class="keyword">atomic_t</span>* v)</span><span class="comment">// 原子变量加1，并且返回v的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_sub_and_test</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span>* v)</span><span class="comment">// 从v减i，如果结果为0就返回真，否则返回假</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_add_and_test</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">atomic_t</span>* v)</span><span class="comment">// 给v加i，如果结果为0就返回真，否则返回假</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_dec_and_test</span><span class="params">(<span class="keyword">atomic_t</span>* v)</span><span class="comment">// 从v减1，如果结果为0就返回真，否则返回假</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atomic_inc_and_test</span><span class="params">(<span class="keyword">atomic_t</span>* v)</span><span class="comment">// 给v加1，如果结果为0就返回真，否则返回假</span></span></span><br></pre></td></tr></table></figure><h2 id="三、原子位操作"><a href="#三、原子位操作" class="headerlink" title="三、原子位操作"></a>三、原子位操作</h2><p>原子位操作不像原子整形变量那样有个<code>atomic_t</code>的数据结构，原子位操作是直接对内存进行操作。</p><p><code>API</code>函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* p)</span><span class="comment">// 将p地址的第nr位置1</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* p)</span><span class="comment">// 将p地址的第nr位清零</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* p)</span><span class="comment">// 将p地址的第nr位翻转</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* p)</span><span class="comment">// 获取p地址的第nr位的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_set_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* p)</span><span class="comment">// 将p地址的第nr位置1，并返回nr位原来的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_clear_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* p)</span><span class="comment">// 将p地址的第nr位清零，并返回nr位原来的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test_and_change_bit</span><span class="params">(<span class="keyword">int</span> nr, <span class="keyword">void</span>* p)</span><span class="comment">// 将p地址的第nr位翻转，并返回nr位原来的值</span></span></span><br></pre></td></tr></table></figure><h2 id="四、自旋锁spinlock"><a href="#四、自旋锁spinlock" class="headerlink" title="四、自旋锁spinlock"></a>四、自旋锁<code>spinlock</code></h2><ul><li>用于多核<code>SMP</code> 。</li><li>适合短时间加锁，轻量级加锁。</li><li>自旋锁会自动禁止抢占。</li><li>使用自旋锁，要注意死锁现象的发生，被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的<code>API函数</code>。（线程与线程中之间，线程与中断之间）。</li></ul><p><code>API</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">spinlock_t</span> lock;<span class="comment">// 定义自旋锁</span></span><br><span class="line">DEFINE_SPINLOCK(<span class="keyword">spinlock_t</span> lock)<span class="comment">// 定义并初始化一个自旋锁变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spin_lock_init</span><span class="params">(<span class="keyword">spinlock_t</span>* lock)</span><span class="comment">// 初始化自旋锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock</span><span class="params">(<span class="keyword">spinlock_t</span>* lock)</span><span class="comment">// 获取指定的自旋锁，也叫加锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock</span><span class="params">(<span class="keyword">spinlock_t</span>* lock)</span><span class="comment">// 是否指定的自旋锁</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spin_trylock</span><span class="params">(<span class="keyword">spinlock_t</span>* lock)</span><span class="comment">// 尝试获取指定的自旋锁，如果没有获取到就返回0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spin_is_locked</span><span class="params">(<span class="keyword">spinlock_t</span>* lock)</span><span class="comment">// 检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回0</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irq</span><span class="params">(<span class="keyword">spinlock_t</span>* lock)</span><span class="comment">// 禁止本地中断，并获取自旋锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_irq</span><span class="params">(<span class="keyword">spinlock_t</span>* lock)</span><span class="comment">// 激活本地中断，并释放自旋锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_lock_irqsave</span><span class="params">(<span class="keyword">spinlock_t</span>* lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><span class="comment">// 保存中断状态，禁止本地中断，并获取自旋锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin_unlock_irqrestore</span><span class="params">(<span class="keyword">spinlock_t</span>* lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> flags)</span><span class="comment">// 将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁。</span></span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SPINLOCK(lock) <span class="comment">// 定义并初始化一个锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程 A */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;<span class="comment">// 中断状态</span></span><br><span class="line">    spin_lock_irqsave(&amp;lock, flags)<span class="comment">// 获取锁</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    spin_unlock_irqrestore(&amp;lock, flags)<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中断服务函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">irq</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    spin_lock(&amp;lock)<span class="comment">// 获取锁</span></span><br><span class="line">    <span class="comment">/* 临界区 */</span></span><br><span class="line">    spin_unlock(&amp;lock)<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、信号量semaphore"><a href="#五、信号量semaphore" class="headerlink" title="五、信号量semaphore"></a>五、信号量<code>semaphore</code></h2><ul><li>信号量可以使等待资源线程进入休眠状态，因此适用于占用资源比较久的场合。</li><li>信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠。</li><li>信号量会将等待信号量中休眠的线程唤醒。</li><li>如果共享资源的持有时间比较短，那就不适合适用信号量了。</li></ul><p><code>API</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_SEAMPHORE(name)<span class="comment">// 定义一个信号量，并且设置信号量的值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sema_init</span><span class="params">(struct semaphore* sem, <span class="keyword">int</span> val)</span><span class="comment">// 初始化信号量sem，设置信号量值为val</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore* sem)</span><span class="comment">// 获取信号量，因为会导致休眠，因此不能在中断中使用。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_trylock</span><span class="params">(struct semaphore* sem)</span><span class="comment">// 尝试获取信号量，如果能获取到信号量就获取，并且返回0。如果不能就返回非0，并且不会进入休眠。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">down_interruptible</span><span class="params">(struct semaphore* sem)</span><span class="comment">// 获取信号量，和down类似，只是使用down进入休眠状态的咸亨不能被信号打断。而使用此函数进入休眠以后是可以被信号打断的。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore* sem)</span><span class="comment">// 释放信号量</span></span></span><br></pre></td></tr></table></figure><p>使用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">sem</span>;</span><span class="comment">// 定义信号量</span></span><br><span class="line">sema_init(&amp;sem, <span class="number">1</span>);<span class="comment">// 初始化信号量</span></span><br><span class="line"></span><br><span class="line">down(&amp;sem);<span class="comment">// 申请信号量</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">up(&amp;sem);<span class="comment">// 释放信号量</span></span><br></pre></td></tr></table></figure><h2 id="六、互斥锁mutex"><a href="#六、互斥锁mutex" class="headerlink" title="六、互斥锁mutex"></a>六、互斥锁<code>mutex</code></h2><ul><li>互斥体可以导致休眠，因此不能在中断中使用，中断中只能使用自旋锁。</li><li>互斥体保护的临界区可以调用引起阻塞的<code>API函数</code> 。</li><li>一次只有一个线程可以持有互斥体，因此必须由<code>mutex</code>的持有者释放<code>mutex</code>。不能递归上锁和解锁。</li></ul><p><code>API</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_MUTEX(name)<span class="comment">// 定义并初始化一个 mutex 变量。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_init</span><span class="params">(struct mutex* lock)</span><span class="comment">// 初始化 mutex。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_lock</span><span class="params">(struct mutex* lock)</span><span class="comment">// 获取 mutex，也就是给 mutex 上锁。如果获取不到就进休眠。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_unlock</span><span class="params">(struct mutex* lock)</span><span class="comment">// 释放 mutex，也就给 mutex 解锁。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mutex_trylock</span><span class="params">(struct mutex* lock)</span><span class="comment">// 尝试获取 mutex，如果成功就返回 1，如果失败就返回 0。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mutex_is_locked</span><span class="params">(struct mutex* lock)</span><span class="comment">// 判断 mutex 是否被获取，如果是的话就返回1，否则返回 0。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mutex_lock_interruptible</span><span class="params">(struct mutex* lock)</span><span class="comment">// 使用此函数获取信号量失败进入休眠以后可以被信号打断</span></span></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span><span class="comment">// 定义一个互斥体</span></span><br><span class="line">mutex_init(&amp;lock);<span class="comment">// 初始化互斥体</span></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;lock);<span class="comment">// 上锁</span></span><br><span class="line"><span class="comment">/* 临界区 */</span></span><br><span class="line">mutex_unlock(&amp;lock);<span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Visio调整图形的间距</title>
    <link href="https://proudrabbit.gitee.io/Visio%E8%B0%83%E6%95%B4%E5%9B%BE%E5%BD%A2%E7%9A%84%E9%97%B4%E8%B7%9D.html"/>
    <id>https://proudrabbit.gitee.io/Visio%E8%B0%83%E6%95%B4%E5%9B%BE%E5%BD%A2%E7%9A%84%E9%97%B4%E8%B7%9D.html</id>
    <published>2020-11-11T13:07:19.000Z</published>
    <updated>2020-11-11T13:42:32.146Z</updated>
    
    <content type="html"><![CDATA[<p>​ 有时候在<code>Visio</code>绘图时我们想要自定义图形之间的间距选项，但是在选中后图形，在<code>开始-&gt;位置-&gt;间距选项</code>中调整了间距后，但是却没有效果。</p><p>​ 解决这个问题的方法很简单，微软也说明了，点击间距选项上的<code>?</code>即可。</p><p><img src="https://i.loli.net/2020/11/11/qQEA8Ky1O39TVoj.png" alt="image-20201111213107031"></p><p>​ 在弹出的网页中，可以看到说明</p><a id="more"></a><p><img src="https://i.loli.net/2020/11/11/nF3IjH6gQTlLK5e.png" alt="image-20201111213237155"></p><p>只要使用连接线将图形相连接，不用全部链接，然后选中要调整的图形。</p><p><img src="https://i.loli.net/2020/11/11/Pv5Jw2cHoOIgWtQ.png" alt="image-20201111213810222"></p><p>然后再次使用<code>间距选项</code>调整间距即可，最后将连接线删除。</p><p><img src="https://i.loli.net/2020/11/11/idpIgm8Vy4teGrR.png" alt="image-20201111213909216"></p>]]></content>
    
    <summary type="html">
    
      Visio有时候使用间距选项调整间距时无法调整间距，这里给出解决办法。
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://proudrabbit.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Visio" scheme="https://proudrabbit.gitee.io/tags/Visio/"/>
    
  </entry>
  
  <entry>
    <title>Word一行排列多个图片并插入题注</title>
    <link href="https://proudrabbit.gitee.io/Word%E4%B8%80%E8%A1%8C%E6%8E%92%E5%88%97%E5%A4%9A%E4%B8%AA%E5%9B%BE%E7%89%87%E5%B9%B6%E6%8F%92%E5%85%A5%E9%A2%98%E6%B3%A8.html"/>
    <id>https://proudrabbit.gitee.io/Word%E4%B8%80%E8%A1%8C%E6%8E%92%E5%88%97%E5%A4%9A%E4%B8%AA%E5%9B%BE%E7%89%87%E5%B9%B6%E6%8F%92%E5%85%A5%E9%A2%98%E6%B3%A8.html</id>
    <published>2020-11-09T01:31:21.000Z</published>
    <updated>2020-11-09T02:25:57.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Word中一行排列多个图片并插入题注"><a href="#Word中一行排列多个图片并插入题注" class="headerlink" title="Word中一行排列多个图片并插入题注"></a>Word中一行排列多个图片并插入题注</h2><h4 id="1-首先根据图片要排列成样式，插入表格。"><a href="#1-首先根据图片要排列成样式，插入表格。" class="headerlink" title="1. 首先根据图片要排列成样式，插入表格。"></a>1. 首先根据图片要排列成样式，插入表格。</h4><h4 id="2-然后将图片放入表格中。就像这样。"><a href="#2-然后将图片放入表格中。就像这样。" class="headerlink" title="2. 然后将图片放入表格中。就像这样。"></a>2. 然后将图片放入表格中。就像这样。</h4><p><img src="https://i.loli.net/2020/11/09/DncZMLsP9YoSkdG.png" alt="表格内插入图片"></p><p>图片大小可能要调一调。</p><a id="more"></a><h4 id="3-对图片插入题注"><a href="#3-对图片插入题注" class="headerlink" title="3. 对图片插入题注"></a>3. 对图片插入题注</h4><p><img src="https://i.loli.net/2020/11/09/7MP2HxEA9foDKnB.png" alt="图片添加题注"></p><h4 id="4-取消表格边框"><a href="#4-取消表格边框" class="headerlink" title="4. 取消表格边框"></a>4. 取消表格边框</h4><p><img src="https://i.loli.net/2020/11/09/7wXfaelDWUtzoxC.png" alt="取消表格边框"></p><h4 id="5-其他地方引用"><a href="#5-其他地方引用" class="headerlink" title="5. 其他地方引用"></a>5. 其他地方引用</h4><p><img src="https://i.loli.net/2020/11/09/HkInlzMGBebjERo.png" alt="其他地方引用"></p>]]></content>
    
    <summary type="html">
    
      Word中排列图片并且添加题注，方便后期引用。
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://proudrabbit.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Word" scheme="https://proudrabbit.gitee.io/tags/Word/"/>
    
  </entry>
  
  <entry>
    <title>寄存器映射</title>
    <link href="https://proudrabbit.gitee.io/%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84.html"/>
    <id>https://proudrabbit.gitee.io/%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%A0%E5%B0%84.html</id>
    <published>2020-09-22T13:31:44.000Z</published>
    <updated>2020-09-22T14:12:05.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寄存器映射原理"><a href="#寄存器映射原理" class="headerlink" title="寄存器映射原理"></a>寄存器映射原理</h2><p>首先看下这行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(GPIOB_BASE+<span class="number">0X00</span>))</span><br></pre></td></tr></table></figure><p>其中<code>GPIOB_BASE</code>是GPIOB寄存器的起始地址，它是一个4字节（32位）的地址。但是电脑不知道它地址，因此需要在前面加一个<code>(unsigned int *)</code>对其进行强制类型转换，这个的作用就是把<code>GPIOB_BASE + 0x00</code>强制转化为地址，因为<code>*</code>符号运算的是地址，所以<code>(unsigned int *)(GPIOB_BASE + 0x00)</code>这一串就成了地址，相当与一个指针常量，当需要向其写入或者读取数据时就可以按按照指针的操作方式对其进行操作，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(GPIOB_BASE+<span class="number">0X00</span>)) = <span class="number">0xffffffff</span>;  <span class="comment">// 向GPIOB_BASE内写入 0xFFFFFFFF;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>然后看下这行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOB        ((GPIO_TypeDef *)GPIOB_BASE)</span></span><br></pre></td></tr></table></figure><p>这个是把<code>GPIOB_BASE</code>这个地址强制转换为<code>GPIO_TypeDef</code>结构体类型的基地址，<code>GPIOB_BASE</code>它的地址分配就和结构体一样了，<code>((GPIO_TypeDef *)GPIOB_BASE)</code>相当于一个结构体指针，因此就可以对结构体成员进行操作了。</p><p>这里是<code>STM32</code>的库函数中的<code>RCC</code>寄存器地址映射代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义RCC寄存器的基地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_BASE              (AHB1PERIPH_BASE + 0x3800)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用结构体来自动对齐RCC相关寄存器</span></span><br><span class="line"><span class="comment">//因为寄存器是32位/4字节，并且是连续的</span></span><br><span class="line"><span class="comment">//根据结构体数据的特性，使用 unsigned int (32位/4字节)可实现自动对齐</span></span><br><span class="line"><span class="comment">//__IO      #define     __IO    volatile</span></span><br><span class="line"><span class="comment">//uint32_t  typedef unsigned int uint32_t;</span></span><br><span class="line"><span class="comment">//RESERVED1[] : 保留地址，因为有些寄存器地址不连续，所以要对其进行占位，达到对齐的目的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> CR;            <span class="comment">/*!&lt; RCC clock control register,                                  Address offset: 0x00 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> PLLCFGR;       <span class="comment">/*!&lt; RCC PLL configuration register,                              Address offset: 0x04 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> CFGR;          <span class="comment">/*!&lt; RCC clock configuration register,                            Address offset: 0x08 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> CIR;           <span class="comment">/*!&lt; RCC clock interrupt register,                                Address offset: 0x0C */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB1RSTR;      <span class="comment">/*!&lt; RCC AHB1 peripheral reset register,                          Address offset: 0x10 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB2RSTR;      <span class="comment">/*!&lt; RCC AHB2 peripheral reset register,                          Address offset: 0x14 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB3RSTR;      <span class="comment">/*!&lt; RCC AHB3 peripheral reset register,                          Address offset: 0x18 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      RESERVED0;     <span class="comment">/*!&lt; Reserved, 0x1C                                                                    */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> APB1RSTR;      <span class="comment">/*!&lt; RCC APB1 peripheral reset register,                          Address offset: 0x20 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> APB2RSTR;      <span class="comment">/*!&lt; RCC APB2 peripheral reset register,                          Address offset: 0x24 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      RESERVED1[<span class="number">2</span>];  <span class="comment">/*!&lt; Reserved, 0x28-0x2C                                                               */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB1ENR;       <span class="comment">/*!&lt; RCC AHB1 peripheral clock register,                          Address offset: 0x30 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB2ENR;       <span class="comment">/*!&lt; RCC AHB2 peripheral clock register,                          Address offset: 0x34 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB3ENR;       <span class="comment">/*!&lt; RCC AHB3 peripheral clock register,                          Address offset: 0x38 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      RESERVED2;     <span class="comment">/*!&lt; Reserved, 0x3C                                                                    */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> APB1ENR;       <span class="comment">/*!&lt; RCC APB1 peripheral clock enable register,                   Address offset: 0x40 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> APB2ENR;       <span class="comment">/*!&lt; RCC APB2 peripheral clock enable register,                   Address offset: 0x44 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      RESERVED3[<span class="number">2</span>];  <span class="comment">/*!&lt; Reserved, 0x48-0x4C                                                               */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB1LPENR;     <span class="comment">/*!&lt; RCC AHB1 peripheral clock enable in low power mode register, Address offset: 0x50 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB2LPENR;     <span class="comment">/*!&lt; RCC AHB2 peripheral clock enable in low power mode register, Address offset: 0x54 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> AHB3LPENR;     <span class="comment">/*!&lt; RCC AHB3 peripheral clock enable in low power mode register, Address offset: 0x58 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      RESERVED4;     <span class="comment">/*!&lt; Reserved, 0x5C                                                                    */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> APB1LPENR;     <span class="comment">/*!&lt; RCC APB1 peripheral clock enable in low power mode register, Address offset: 0x60 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> APB2LPENR;     <span class="comment">/*!&lt; RCC APB2 peripheral clock enable in low power mode register, Address offset: 0x64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      RESERVED5[<span class="number">2</span>];  <span class="comment">/*!&lt; Reserved, 0x68-0x6C                                                               */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> BDCR;          <span class="comment">/*!&lt; RCC Backup domain control register,                          Address offset: 0x70 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> CSR;           <span class="comment">/*!&lt; RCC clock control &amp; status register,                         Address offset: 0x74 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>      RESERVED6[<span class="number">2</span>];  <span class="comment">/*!&lt; Reserved, 0x78-0x7C                                                               */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> SSCGR;         <span class="comment">/*!&lt; RCC spread spectrum clock generation register,               Address offset: 0x80 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> PLLI2SCFGR;    <span class="comment">/*!&lt; RCC PLLI2S configuration register,                           Address offset: 0x84 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> PLLSAICFGR;    <span class="comment">/*!&lt; RCC PLLSAI configuration register,                           Address offset: 0x88 */</span></span><br><span class="line">    __IO <span class="keyword">uint32_t</span> DCKCFGR;       <span class="comment">/*!&lt; RCC Dedicated Clocks configuration register,                 Address offset: 0x8C */</span></span><br><span class="line"></span><br><span class="line">&#125; RCC_TypeDef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将RCC_BASE 转换为RCC_TypeDef型指针</span></span><br><span class="line"><span class="comment">// 这样结构体就和寄存器地址一一对应起来了 寄存器映射</span></span><br><span class="line"><span class="comment">// 使用指针RCC 即可对其进行访问。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC      ((RCC_TypeDef *) RCC_BASE)</span></span><br></pre></td></tr></table></figure><p>这是RCC寄存器映射表，（详细的映射表请看STM32F4XX参考手册）</p><p><img src="https://i.loli.net/2020/09/22/2LSEdfQt3KiFvCr.png" alt="RCC寄存器映射表"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;寄存器映射原理&quot;&gt;&lt;a href=&quot;#寄存器映射原理&quot; class=&quot;headerlink&quot; title=&quot;寄存器映射原理&quot;&gt;&lt;/a&gt;寄存器映射原理&lt;/h2&gt;&lt;p&gt;首先看下这行代码&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;((&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *)(GPIOB_BASE+&lt;span class=&quot;number&quot;&gt;0X00&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;其中&lt;code&gt;GPIOB_BASE&lt;/code&gt;是GPIOB寄存器的起始地址，它是一个4字节（32位）的地址。但是电脑不知道它地址，因此需要在前面加一个&lt;code&gt;(unsigned int *)&lt;/code&gt;对其进行强制类型转换，这个的作用就是把&lt;code&gt;GPIOB_BASE + 0x00&lt;/code&gt;强制转化为地址，因为&lt;code&gt;*&lt;/code&gt;符号运算的是地址，所以&lt;code&gt;(unsigned int *)(GPIOB_BASE + 0x00)&lt;/code&gt;这一串就成了地址，相当与一个指针常量，当需要向其写入或者读取数据时就可以按按照指针的操作方式对其进行操作，如&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;*((&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *)(GPIOB_BASE+&lt;span class=&quot;number&quot;&gt;0X00&lt;/span&gt;)) = &lt;span class=&quot;number&quot;&gt;0xffffffff&lt;/span&gt;;  &lt;span class=&quot;comment&quot;&gt;// 向GPIOB_BASE内写入 0xFFFFFFFF;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://proudrabbit.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu修改默认终端</title>
    <link href="https://proudrabbit.gitee.io/Ubuntu%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF.html"/>
    <id>https://proudrabbit.gitee.io/Ubuntu%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF.html</id>
    <published>2020-09-19T13:59:47.000Z</published>
    <updated>2020-09-19T14:13:42.917Z</updated>
    
    <content type="html"><![CDATA[<p>在终端中输入如下命令即可，当然前提是安装了<code>Debian</code>的深度终端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.default-applications.terminal exec &#x2F;usr&#x2F;bin&#x2F;deepin-terminal  </span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.desktop.default-applications.terminal exec-arg &quot;-x&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在Ubuntu下修改默认终端为Debian终端。
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://proudrabbit.gitee.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（六）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89.html</id>
    <published>2020-09-19T13:55:47.000Z</published>
    <updated>2020-12-19T14:40:04.743Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><p><strong>正常工作中进行驱动开发的方式——子系统。</strong></p><h2 id="一、pinctrl子系统"><a href="#一、pinctrl子系统" class="headerlink" title="一、pinctrl子系统"></a>一、pinctrl子系统</h2><p>​ 借助<code>pinctrl</code>来设置一个<code>pin</code>的复用和电气属性。</p><p>​ <code>pinctrl</code> 子系统主要工作内容如下：</p><ol><li>获取设备树中的<code>pin</code>信息。</li><li>根据获取到的<code>pin</code>信息来设置<code>pin</code>的复用功能。</li><li>根据获取到的<code>pin</code>信息来设置<code>pin</code>的电气特性，比如上/下拉、速度、驱动能力等。</li></ol><a id="more"></a><p>对于使用者来说，只要在设备树里面设置某个<code>pin</code>的相关属性即可，其他的初始化工作由<code>pinctrl</code>子系统来完成，<code>pinctrl</code>子系统源码目录为<code>drivers/pinctrl</code>。根据设备的类型，会创建对应的子节点，然后设备所用<code>pin</code>都放到此节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">imx6ul-evk &#123;</span><br><span class="line">pinctrl_hog_1: hoggrp-1 &#123;</span><br><span class="line">fsl,pins &#x3D; &lt;</span><br><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO190x17059 &#x2F;* SD1 CD *&#x2F;</span><br><span class="line">MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT0x17059 &#x2F;* SD1 VSELECT *&#x2F;</span><br><span class="line">MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        0x17059 &#x2F;* SD1 RESET *&#x2F;</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、gpio子系统"><a href="#二、gpio子系统" class="headerlink" title="二、gpio子系统"></a>二、gpio子系统</h2><p>​ 使用<code>gpio</code>子系统来使用<code>gpio</code>。</p><h2 id="三、驱动编写"><a href="#三、驱动编写" class="headerlink" title="三、驱动编写"></a>三、驱动编写</h2><ol><li>设备树修改</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">  gpioled &#123;</span><br><span class="line">compatible = <span class="string">"atkalpha,gpioled"</span>;</span><br><span class="line">pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_gpioled&gt;;</span><br><span class="line">led-gpios = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">status = <span class="string">"okay"</span>;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;iomuxc &#123;</span><br><span class="line">pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">imx6ul-evk &#123;</span><br><span class="line">pinctrl_hog_1: hoggrp<span class="number">-1</span> &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO19<span class="number">0x17059</span> <span class="comment">/* SD1 CD */</span></span><br><span class="line">MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT<span class="number">0x17059</span> <span class="comment">/* SD1 VSELECT */</span></span><br><span class="line">MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        <span class="number">0x17059</span> <span class="comment">/* SD1 RESET */</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自己定义的led */</span></span><br><span class="line">pinctrl_gpioled: ledgrp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO03__GPIO1_IO03<span class="number">0X10B0</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">        ......</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;tsc &#123;</span><br><span class="line">pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_tsc&gt;;</span><br><span class="line">xnur-gpio = &lt;&amp;gpio1 <span class="number">3</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">measure-<span class="built_in">delay</span>-time = &lt;<span class="number">0xffff</span>&gt;;</span><br><span class="line">pre-charge-time = &lt;<span class="number">0xfff</span>&gt;;</span><br><span class="line">status = <span class="string">"disable"</span>;<span class="comment">// 因为和LED灯使用引脚冲突，所以需要关闭</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>驱动程序</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOLED_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOLED_NAME<span class="meta-string">"gpioled"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDOFF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDON 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;</span><br><span class="line"><span class="keyword">int</span> major;</span><br><span class="line"><span class="keyword">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span></span><br><span class="line"><span class="keyword">int</span> led_gpio;<span class="comment">/* led 所使用的 GPIO 编号 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> <span class="title">gpioled</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;gpioled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">led_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gpioled_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = copy_from_user(databuff, buf, count);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"kernel write failed!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(databuff[<span class="number">0</span>] == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">gpio_set_value(dev-&gt;led_gpio, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = led_open,</span><br><span class="line">.<span class="built_in">release</span> = led_release,</span><br><span class="line">.<span class="built_in">write</span> = led_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册字符设备驱动 */</span></span><br><span class="line">gpioled.major = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(gpioled.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 给定设备号 */</span></span><br><span class="line">gpioled.devid = MKDEV(gpioled.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(gpioled.devid, GPIOLED_CNT, GPIOLED_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">alloc_chrdev_region(&amp;gpioled.devid, <span class="number">0</span>,GPIOLED_CNT,GPIOLED_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化cdev */</span></span><br><span class="line">gpioled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;gpioled.cdev, &amp;led_fops);</span><br><span class="line">ret = cdev_add(&amp;gpioled.cdev, gpioled.devid, GPIOLED_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建类 */</span></span><br><span class="line">gpioled<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">GPIOLED_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(gpioled.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(gpioled.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建设备节点 */</span></span><br><span class="line">gpioled.device = device_create(gpioled.class, <span class="literal">NULL</span>, gpioled.devid, <span class="literal">NULL</span>, GPIOLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(gpioled.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(gpioled.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取设备节点 */</span></span><br><span class="line">gpioled.nd = of_find_node_by_path(<span class="string">"/gpioled"</span>);</span><br><span class="line"><span class="keyword">if</span> (gpioled.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取LED对应的GPIO */</span></span><br><span class="line">gpioled.led_gpio = of_get_named_gpio(gpioled.nd, <span class="string">"led-gpios"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (gpioled.led_gpio &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 申请IO */</span></span><br><span class="line">ret = gpio_request(gpioled.led_gpio, <span class="string">"led_gpio"</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"failed to request the led\r\n"</span>);</span><br><span class="line"><span class="comment">/* <span class="doctag">NOTE:</span>申请失败的话，大部分原因这个IO被别的外设占用</span></span><br><span class="line"><span class="comment"> * 需要在设备树中屏蔽相关代码，或者status属性值设置为disable</span></span><br><span class="line"><span class="comment"> * 检查复用，也就是pinctl</span></span><br><span class="line"><span class="comment"> * gpio使用 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用IO 设置为输出 默认为低电平*/</span></span><br><span class="line">ret = gpio_direction_output(gpioled.led_gpio, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_setoutput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_setoutput:</span><br><span class="line">gpio_free(gpioled.led_gpio);</span><br><span class="line">fail_findnd:</span><br><span class="line">device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(gpioled.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;gpioled.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(gpioled.devid, GPIOLED_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">led_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 释放IO */</span></span><br><span class="line">gpio_free(gpioled.led_gpio);</span><br><span class="line">device_destroy(gpioled.class, gpioled.devid);</span><br><span class="line">class_destroy(gpioled.class);</span><br><span class="line">cdev_del(&amp;gpioled.cdev);</span><br><span class="line">unregister_chrdev_region(gpioled.devid,GPIOLED_CNT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（五）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89.html</id>
    <published>2020-09-19T13:51:40.000Z</published>
    <updated>2020-12-19T14:24:21.895Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="一、什么是设备树"><a href="#一、什么是设备树" class="headerlink" title="一、什么是设备树"></a>一、什么是设备树</h2><ol><li>设备树：设备和树。</li><li>描述设备树的文件叫做<code>DTS</code>(Device Tree Source)，这个 <code>DTS</code> 文件采用树形结构描述本板级设备，也就是开发板上的设备信息。比如CPU数量、内存基地址、<code>IIC</code> 接口上外接了哪些设备等等。</li><li>由于以前板级信息都是写到 <code>.c</code> 文件里面，导致 <code>linux</code> 内核臃肿。因此将板级信息做成独立的格式，文件扩展名为 <code>.dts</code> 。一个平台或者机器对应一个 <code>.dts</code> 。</li></ol><a id="more"></a><h2 id="二、DTS、DTB和DTC的关系"><a href="#二、DTS、DTB和DTC的关系" class="headerlink" title="二、DTS、DTB和DTC的关系"></a>二、DTS、DTB和DTC的关系</h2><p><code>.dts</code> 相当于 <code>.c</code> ，就是DTS源码文件。<code>DTC</code> 工具相当于 <code>gcc</code> 编译器，将 <code>.dts</code> 编译成 <code>.dtb</code> 。<code>dtb</code> 相当于 <code>bin</code> 文件或可执行文件。</p><p>通过 <code>make dtbs</code> 命令来编译所有的 <code>.dts</code> 文件，通过 <code>make xxxxx.dtb</code> 来编译对应的 <code>.dts</code> 文件，需要在 <code>makefile</code> 中添加 <code>.dts</code> 文件所在路径。编译 <code>dts</code> 文件的 <code>Makefile</code> 在 <code>arch/arm/boot/dts</code> 下。</p><h2 id="三、DTS基本语法"><a href="#三、DTS基本语法" class="headerlink" title="三、DTS基本语法"></a>三、DTS基本语法</h2><p>这篇<a href="https://blog.csdn.net/u014717231/article/details/53139968" target="_blank" rel="noopener">DTS入门知识</a>博客对<code>DTS</code>进行了入门的讲解。</p><ol><li><p>DTS是 <code>/</code> 开始。</p></li><li><p>从 <code>/</code> 根节点开始描述设备信息。</p></li><li><p>在 <code>/</code> 根节点外有一些 <code>&amp;cpu0</code> 的语句是”追加“。</p></li><li><p>节点名字的要求</p><p><code>label: node-name@unit-address</code> 标签: 节点名字@地址。</p><ul><li><code>label</code> ：为了方便的访问节点。</li><li><code>node-name</code> ：可使用的字符 [0~9] [a~z] [A~Z] [ , . + - _ ]。约定使用小写。</li><li><code>unit-address</code> ：一般是外设寄存器的起始地址。有的是外设的设备地址或者其他含义，需要根据情况来分析。</li></ul></li></ol><h2 id="四、设备树在系统中的体现"><a href="#四、设备树在系统中的体现" class="headerlink" title="四、设备树在系统中的体现"></a>四、设备树在系统中的体现</h2><p>系统启动以后可以在根文件系统里面看到设备树的节点信息。在 <code>/proc/device-tree/</code> <code>-&gt;</code> <code>/sys/firmware/devicetree/base</code> 目录下存放着设备树信息。</p><p>内核启动的时候会解析设备树，然后在 <code>/proc/device-tree/</code>目录下呈现出来。</p><h2 id="五、特殊节点"><a href="#五、特殊节点" class="headerlink" title="五、特殊节点"></a>五、特殊节点</h2><ol><li><code>aliases</code> 节点，对节点进行取别名。</li><li><code>chosen</code> 节点，主要目的就是将 <code>uboot</code> 里面的 <code>bootargs</code> 环境变量值，传递给 <code>linux</code> 内核作为命令行参数 <code>cmd line</code> 。<code>uboot</code> 会将 <code>bootargs</code> 环境变量写入 <code>chosen</code> 节点中，通过 <code>fdt_chosen</code> 函数。</li></ol><h2 id="六、属性"><a href="#六、属性" class="headerlink" title="六、属性"></a>六、属性</h2><table><thead><tr><th>嵌入式不常用或弃用属性</th><th>实例</th><th>作用</th></tr></thead><tbody><tr><td>ranges</td><td>ranges = &lt;child-bus-address,parent-bus-address,length&gt; / <code>ranges;</code></td><td>ranges是一个地址映射/转换表,ranges 属性每个项目由子地址、父地址和地址空间长度这三部分组成:<br><code>child-bus-address</code>:子总线地址空间的物理地址,由父节点的#address-cells 确定此物理地址所占用的字长。<br><code>parent-bus-address</code>:父总线地址空间的物理地址,同样由父节点的#address-cells 确定此物理地址所占用的字长。<br><code>length</code>:子地址空间的长度,由父节点的#size-cells 确定此地址长度所占用的字长。<br>如果 ranges 属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换。</td></tr><tr><td>name</td><td></td><td>name 属性用于记录节点名字,name 属性已经被弃用,不推荐使用name 属性,一些老的设备树文件可能会使用此属性。</td></tr><tr><td>device_type</td><td>device_type = “cpu”;</td><td>用于描述设备的 FCode,但是设备树没有 FCode,所以此属性也被抛弃了。此属性只能用于 cpu 节点或者 memory 节点。imx6ull.dtsi 的 cpu0 节点用到了此属性。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ranges属性不为空时 */</span></span><br><span class="line">soc &#123;</span><br><span class="line">compatible = <span class="string">"simple-bus"</span>;</span><br><span class="line"><span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line"><span class="meta">#size-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">ranges = &lt;<span class="number">0x0</span> <span class="number">0xe0000000</span> <span class="number">0x00100000</span>&gt;;</span><br><span class="line"></span><br><span class="line">serial &#123;</span><br><span class="line">device_type = <span class="string">"serial"</span>;</span><br><span class="line">compatible = <span class="string">"ns16550"</span>;</span><br><span class="line">reg = &lt;<span class="number">0x4600</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">clock-frequency = &lt;<span class="number">0</span>&gt;;</span><br><span class="line"><span class="built_in">interrupts</span> = &lt;<span class="number">0xA</span> <span class="number">0x8</span>&gt;;</span><br><span class="line">interrupt-parent = &lt;&amp;ipic&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">第 <span class="number">6</span> 行，节点 soc 定义的 ranges 属性，值为&lt;<span class="number">0x0</span> <span class="number">0xe0000000</span> <span class="number">0x00100000</span>&gt;，此属性值指定</span><br><span class="line">了一个 <span class="number">1024</span>KB(<span class="number">0x00100000</span>)的地址范围，子地址空间的物理起始地址为 <span class="number">0x0</span>，父地址空间的物</span><br><span class="line">理起始地址为 <span class="number">0xe0000000</span>。</span><br><span class="line">第 <span class="number">11</span> 行， serial 是串口设备节点， reg 属性定义了 serial 设备寄存器的起始地址为 <span class="number">0x4600</span>，</span><br><span class="line">寄存器长度为 <span class="number">0x100</span>。经过地址转换， serial 设备可以从 <span class="number">0xe0004600</span> 开始进行读写操作，</span><br><span class="line"><span class="number">0xe0004600</span> = <span class="number">0x4600</span> + <span class="number">0xe0000000</span>。</span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>属性</th><th>实例/可选值</th><th>作用</th></tr></thead><tbody><tr><td>compatible</td><td>compatible = “fsl,imx6ul-evk-wm8960”,”fsl,imx-audio-wm8960”;</td><td>设备兼容属性</td></tr><tr><td>mode</td><td>model = “wm8960-audio”;</td><td>描述设备模块信息</td></tr><tr><td>status</td><td><code>okay</code>/<code>disabled</code>/<code>fail</code>/<code>fail-sss</code></td><td>描述设备状态</td></tr><tr><td>#address-cells</td><td>#address-cells = &lt;1&gt;;</td><td>描述了<strong>子节点</strong><code>reg</code>属性中地址信息所占用的字长(32 位)</td></tr><tr><td>#size-cells</td><td>#size-cells = &lt;1&gt;;</td><td>描述了<strong>子节点</strong><code>reg</code>属性中长度信息所占的字长(32 位)</td></tr><tr><td>reg</td><td>reg = &lt;address1 length1 address2 length2……&gt;</td><td>描述设备起始地址和长度</td></tr></tbody></table><h2 id="七、特殊的属性"><a href="#七、特殊的属性" class="headerlink" title="七、特殊的属性"></a>七、特殊的属性</h2><p><code>compatible</code>属性，值是字符串。</p><p>根节点<code>/</code>下的<code>compatible</code>属性，内核在启动的时候会检查是否支持此平台，在以前不使用设备树的时候会通过<code>machine id</code>来判断内核是否支持此机器。使用设备数后不再使用机器ID，而是使用根节点<code>/</code>下的<code>compatible</code>属性。</p><p>未使用设备树的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACHINE_START(_type,_name)\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> __<span class="title">mach_desc_</span>##_<span class="title">type</span>\</span></span><br><span class="line"><span class="class">__<span class="title">used</span>\</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((__<span class="title">section__</span>(".<span class="title">arch</span>.<span class="title">info</span>.<span class="title">init</span>"))) = &#123;</span>\</span><br><span class="line">.nr = MACH_TYPE_##_type,\</span><br><span class="line">.name = _name,\</span><br><span class="line">    </span><br><span class="line">#define MACHINE_END\</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用设备树的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DT_MACHINE_START(_name, _namestr)\</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> __<span class="title">mach_desc_</span>##_<span class="title">name</span>\</span></span><br><span class="line"><span class="class">__<span class="title">used</span> \</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((__<span class="title">section__</span>(".<span class="title">arch</span>.<span class="title">info</span>.<span class="title">init</span>"))) = &#123;</span> \</span><br><span class="line">.nr = ~<span class="number">0</span>,\</span><br><span class="line">.name = _namestr,\</span><br><span class="line"></span><br><span class="line">#define MACHINE_END\</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="八、Linux内核的OF操作函数"><a href="#八、Linux内核的OF操作函数" class="headerlink" title="八、Linux内核的OF操作函数"></a>八、Linux内核的OF操作函数</h2><ol><li><p>驱动如何获取到设备树中的设备信息。在驱动中使用<code>OF</code>函数获取设备树属性内容。</p><ol start="2"><li><p>驱动要想获取到设备树节点内容，首先要找到节点。</p></li><li><p>查找节点的of函数：</p><ul><li><p><code>of_find_node_by_name</code>函数</p><p>of_find_node_by_name 函数通过节点名字查找指定的节点,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_node_by_name</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>from：开始查找的节点,如果为<code>NULL</code>表示从根节点开始查找整个设备树。<br>name：要查找的节点名字。<br>返回值：找到的节点,如果为<code>NULL</code>表示查找失败。</p></li><li><p><code>of_find_node_by_type</code>函数</p><p>of_find_node_by_type 函数通过<code>device_type</code>属性查找指定的节点,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_node_by_type</span><span class="params">(struct device_node *from, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>from：开始查找的节点,如果为 <code>NULL</code> 表示从根节点开始查找整个设备树。<br>type：要查找的节点对应的 <code>type</code> 字符串,也就是<code>device_type</code>属性值。<br>返回值：找到的节点,如果为<code>NULL</code>表示查找失败。</p></li><li><p><code>of_find_compatible_node</code>函数</p><p>of_find_compatible_node 函数根据<code>device_type</code>和<code>compatible</code>这两个属性查找指定的节点,<br>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_compatible_node</span><span class="params">(struct device_node *from,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *type, <span class="keyword">const</span> <span class="keyword">char</span> *compatible)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>from：开始查找的节点,如果为<code>NULL</code>表示从根节点开始查找整个设备树。<br>type：要查找的节点对应的<code>type</code>字符串,也就是<code>device_type</code>属性值,可以为<code>NULL</code>,表示忽略掉<code>device_type</code>属性。<br>compatible：要查找的节点所对应的<code>compatible</code>属性列表。<br>返回值：找到的节点,如果为<code>NULL</code>表示查找失败。</p></li><li><p><code>of_find_matching_node_and_match</code>函数</p><p>of_find_matching_node_and_match 函数通过<code>of_device_id</code>匹配表来查找指定的节点,函数原<br>型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_matching_node_and_match</span><span class="params">(struct device_node *from,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">const</span> struct of_device_id *matches,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">const</span> struct of_device_id **match)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:</p><p>from：开始查找的节点,如果为<code>NULL</code>表示从根节点开始查找整个设备树。<br>matches：<code>of_device_id</code>匹配表,也就是在此匹配表里面查找节点。<br>match：找到的匹配的<code>of_device_id</code>。</p><p>返回值：找到的节点,如果为<code>NULL</code>表示查找失败。</p></li><li><p><code>of_find_node_by_path</code>函数<br>of_find_node_by_path 函数通过路径来查找指定的节点,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_find_node_by_path</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>path：带有全路径的节点名,可以使用节点的别名,比如<code>/backlight</code>就是<code>backlight</code>这个节点的全路径。<br>返回值：找到的节点,如果为<code>NULL</code>表示查找失败。</p></li></ul></li></ol></li><li><p>查找父/子节点的of函数</p><ul><li><p><code>of_get_parent</code>函数</p><p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话),函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_get_parent</span><span class="params">(<span class="keyword">const</span> struct device_node *node)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:</p><p>node：要查找的父节点的节点。<br>返回值：找到的父节点。</p></li><li><p><code>of_get_next_child</code>函数</p><p>of_get_next_child 函数用迭代的查找子节点,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct device_node *<span class="title">of_get_next_child</span><span class="params">(<span class="keyword">const</span> struct device_node *node,</span></span></span><br><span class="line"><span class="function"><span class="params">struct device_node *prev)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>node：父节点。<br>prev：前一个子节点,也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为<code>NULL</code>,表示从第一个子节点开始。<br>返回值：找到的下一个子节点。</p></li></ul></li><li><p>提取属性值的of函数</p><p>节点的属性信息里面保存了驱动所需要的内容,因此对于属性值的提取非常重要, Linux 内<br>核中使用结构体<code>property</code>表示属性,此结构体同样定义在文件<code>include/linux/of.h</code>中,内容如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> *name;<span class="comment">/* 属性名字 */</span></span><br><span class="line"><span class="keyword">int</span> length; <span class="comment">/* 属性长度*/</span></span><br><span class="line"><span class="keyword">void</span> *value;<span class="comment">/* 属性值 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">next</span>;</span><span class="comment">/* 下一个属性*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _flags; </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> unique_id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bin_attribute</span> <span class="title">attr</span>;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>of_find_property</code>函数</p><p>of_find_property 函数用于查找指定的属性,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">property *<span class="title">of_find_property</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name,<span class="keyword">int</span> *lenp)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>name：属性名字。<br>lenp：属性值的字节数<br>返回值：找到的属性。</p></li><li><p><code>of_property_count_elems_of_size</code>函数</p><p>of_property_count_elems_of_size 函数用于获取属性中元素的数量,比如<code>reg</code>属性值是一个<br>数组,那么使用此函数可以获取到这个数组的大小,此函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_count_elems_of_size</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *propname, <span class="keyword">int</span> elem_size)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>proname：需要统计元素数量的属性名字。<br>elem_size：元素长度。<br>返回值：得到的属性元素数量。</p></li><li><p><code>of_property_read_u32_index</code>函数</p><p>of_property_read_u32_index 函数用于从属性中获取指定标号的<code>u32</code>类型数据值(无符号 32<br>位),比如某个属性有多个<code>u32</code>类型的值,那么就可以使用此函数来获取指定标号的数据值,此<br>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32_index</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *propname, u32 index,</span></span></span><br><span class="line"><span class="function"><span class="params">                               u32 *out_value)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>proname：要读取的属性名字。<br>index：要读取的值标号。<br>out_value：读取到的值<br>返回值：0 读取成功,负值,读取失败,<code>-EINVAL</code>表示属性不存在,<code>-ENODATA</code>表示没有<br>要读取的数据,<code>-EOVERFLOW</code>表示属性值列表太小。</p></li><li><p><code>of_property_read_u8_array</code> 函数<br><code>of_property_read_u16_array</code> 函数<br><code>of_property_read_u32_array</code> 函数<br><code>of_property_read_u64_array</code> 函数</p><p>这 4 个函数分别是读取属性中 <code>u8</code>、<code>u16</code>、<code>u32</code> 和 <code>u64</code> 类型的数组数据,比如大多数的<code>reg</code>属<br>性都是数组数据,可以使用这 4 个函数一次读取出<code>reg</code>属性中的所有数据。这四个函数的原型<br>如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u8_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *propname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                u8 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u16_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *propname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                u16 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *propname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                u32 *out_values, <span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u64_array</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *propname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                u64 *out_values,<span class="keyword">size_t</span> sz)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>proname：要读取的属性名字。<br>out_value：读取到的数组值,分别为<code>u8</code>、<code>u16</code>、<code>u32</code>和<code>u64</code>。<br>sz：要读取的数组元素数量。<br>返回值：0,读取成功,负值,读取失败,<code>-EINVAL</code>表示属性不存在,<code>-ENODATA</code>表示没<br>有要读取的数据,<code>-EOVERFLOW</code>表示属性值列表太小。</p></li><li><p><code>of_property_read_u8</code> 函数<br><code>of_property_read_u16</code> 函数<br><code>of_property_read_u32</code> 函数<br><code>of_property_read_u64</code> 函数</p><p>有些属性只有一个整形值,这四个函数就是用于读取这种只有一个整形值的属性,分别用<br>于读取 u8、u16、u32 和 u64 类型属性值,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u8</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *propname, u8*out_value)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u16</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">char</span> *propname, u16 *out_value)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u32</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">char</span>*propname, u32 *out_value)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_u64</span><span class="params">(<span class="keyword">const</span> struct device_node *np,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">char</span> *propname, u64 *out_value)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>proname：要读取的属性名字。<br>out_value：读取到的数组值。<br>返回值：0,读取成功,负值,读取失败,<code>-EINVAL</code>表示属性不存在,<code>-ENODATA</code>表示没<br>有要读取的数据,<code>-EOVERFLOW</code>表示属性值列表太小。</p></li><li><p><code>of_property_read_string</code> 函数</p><p>of_property_read_string 函数用于读取属性中字符串值,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_property_read_string</span><span class="params">(struct device_node *np,<span class="keyword">const</span> <span class="keyword">char</span> *propname,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> **out_string)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>proname：要读取的属性名字。<br>out_string：读取到的字符串值。<br>返回值：0,读取成功,负值,读取失败。</p></li><li><p><code>of_n_addr_cells</code> 函数</p><p>of_n_addr_cells 函数用于获取<code>#address-cells</code>属性值,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_n_addr_cells</span><span class="params">(struct device_node *np)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>返回值：获取到的<code>#address-cells</code>属性值。</p></li><li><p><code>of_n_size_cells</code> 函数</p><p>of_size_cells 函数用于获取<code>#size-cells</code>属性值,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_n_size_cells</span><span class="params">(struct device_node *np)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>返回值：获取到的<code>#size-cells</code>属性值。</p></li></ul></li><li><p>其他常用of函数</p><ul><li><p><code>of_device_is_compatible</code>函数</p><p>of_device_is_compatible 函数用于查看节点的<code>compatible</code>属性是否有包含<code>compat</code>指定的字<br>符串,也就是检查设备节点的兼容性,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_device_is_compatible</span><span class="params">(<span class="keyword">const</span> struct device_node *device,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">char</span> *compat)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>device：设备节点。<br>compat：要查看的字符串。<br>返回值： 0,节点的<code>compatible</code>属性中不包含<code>compat</code>指定的字符串;正数,节点的 <code>compatible</code><br>属性中包含<code>compat</code>指定的字符串。</p></li><li><p><code>of_get_address</code> 函数</p><p>of_get_address 函数用于获取地址相关属性,主要是<code>reg</code>或者<code>assigned-addresses</code>属性<br>值,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> __be32 *<span class="title">of_get_address</span><span class="params">(struct device_node *dev,<span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                             u64 *<span class="built_in">size</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> *flags)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>dev：设备节点。<br>index：要读取的地址标号。<br>size：地址长度。<br>flags：参数,比如<code>IORESOURCE_IO</code>、<code>IORESOURCE_MEM</code>等<br>返回值：读取到的地址数据首地址,为<code>NULL</code>的话表示读取失败。</p></li><li><p><code>of_translate_address</code> 函数</p><p>of_translate_address 函数负责将从设备树读取到的地址转换为物理地址,函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u64 <span class="title">of_translate_address</span><span class="params">(struct device_node *dev,<span class="keyword">const</span> __be32 *in_addr)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>dev：设备节点。<br>in_addr：要转换的地址。<br>返回值：得到的物理地址,如果为<code>OF_BAD_ADDR</code>的话表示转换失败。</p></li><li><p><code>of_address_to_resource</code> 函数</p><p><code>IIC</code>、<code>SPI</code>、<code>GPIO</code> 等这些外设都有对应的寄存器,这些寄存器其实就是一组内存空间,Linux<br>内核使用<code>resource</code>结构体来描述一段内存空间,“ resource”翻译出来就是“资源”,因此用<code>resource</code>结构体描述的都是设备资源信息,<code>resource</code>结构体定义在文件<code>include/linux/ioport.h</code>中,定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> &#123;</span></span><br><span class="line">    <span class="keyword">resource_size_t</span> start;</span><br><span class="line">    <span class="keyword">resource_size_t</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 32 位的 SOC 来说,<code>resource_size_t</code>是 <code>u32</code> 类型的。其中<code>start</code>表示开始地址,<code>end</code> 表示结束地址,<code>name</code>是这个资源的名字,<code>flags</code>是资源标志位,一般表示资源类型,可选的资源标志<br>定义在文件<code>include/linux/ioport.h</code>中,如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_BITS 0x000000ff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_TYPE_BITS 0x00001f00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IO 0x00000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM 0x00000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_REG 0x00000300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_IRQ 0x00000400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DMA 0x00000800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_BUS 0x00001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_PREFETCH 0x00002000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_READONLY 0x00004000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_CACHEABLE 0x00008000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_RANGELENGTH 0x00010000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_SHADOWABLE 0x00020000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_SIZEALIGN 0x00040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_STARTALIGN 0x00080000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MEM_64 0x00100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_WINDOW 0x00200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_MUXED 0x00400000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_EXCLUSIVE 0x08000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_DISABLED 0x10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_UNSET 0x20000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_AUTO 0x40000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IORESOURCE_BUSY 0x80000000</span></span><br></pre></td></tr></table></figure><p>一般最常见的资源标志就是<code>IORESOURCE_MEM</code>、 <code>IORESOURCE_REG</code>和<code>IORESOURCE_IRQ</code>等。接下来我们回到<code>of_address_to_resource</code>函数,此函数看名字像是从设备树里面提取资源值,但是本质上就是将<code>reg</code>属性值,然后将其转换为<code>resource</code>结构体类型,函数原型如下所示:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">of_address_to_resource</span><span class="params">(struct device_node *dev,<span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                           struct resource *r)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>dev：设备节点。<br>index：地址资源标号。<br>r：得到的<code>resource</code>类型的资源值。<br>返回值：0,成功;负值,失败。</p></li><li><p><code>of_iomap</code>函数</p><p>of_iomap 函数用于直接内存映射,以前我们会通过<code>ioremap</code>函数来完成物理地址到虚拟地<br>址的映射,采用设备树以后就可以直接通过<code>of_iomap</code>函数来获取内存地址所对应的虚拟地址,<br>不需要使用<code>ioremap</code>函数了。当然了,你也可以使用<code>ioremap</code>函数来完成物理地址到虚拟地址<br>的内存映射,只是在采用设备树以后,大部分的驱动都使用<code>of_iomap</code>函数了，<code>of_iomap</code>函数本<br>质上也是将<code>reg</code>属性中地址信息转换为虚拟地址,如果<code>reg</code>属性有多段的话,可以通过<code>index</code>参<br>数指定要完成内存映射的是哪一段,<code>of_iomap</code>函数原型如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __iomem *<span class="title">of_iomap</span><span class="params">(struct device_node *np, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure><p>函数参数和返回值含义如下:<br>np：设备节点。<br>index：<code>reg</code>属性中要完成内存映射的段,如果<code>reg</code>属性只有一段的话<code>index</code>就设置为 0。<br>返回值：经过内存映射后的虚拟内存首地址,如果为<code>NULL</code>的话表示内存映射失败。</p></li></ul></li></ol><h2 id="九、设备树添加内容（开发中一般不使用这种方式）"><a href="#九、设备树添加内容（开发中一般不使用这种方式）" class="headerlink" title="九、设备树添加内容（开发中一般不使用这种方式）"></a>九、设备树添加内容（开发中一般不使用这种方式）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 自己添加的节点 2020-9-17 */</span></span><br><span class="line">alphaled &#123;</span><br><span class="line">    <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">    <span class="meta">#size-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">    compatible = <span class="string">"atkalpha-led"</span>;</span><br><span class="line">    status = <span class="string">"okay"</span>;</span><br><span class="line">    reg = &lt;<span class="number">0X020C406C</span> <span class="number">0X04</span><span class="comment">/* CCM_CCGR1_BASE */</span></span><br><span class="line">        <span class="number">0X020E0068</span> <span class="number">0X04</span><span class="comment">/* SW_MUX_GPIO1_IO03_BASE */</span></span><br><span class="line">        <span class="number">0X020E02F4</span> <span class="number">0X04</span><span class="comment">/* SW_PAD_GPIO1_IO03_BASE */</span></span><br><span class="line">        <span class="number">0X0209C000</span> <span class="number">0X04</span><span class="comment">/* GPIO1_DR_BASE */</span></span><br><span class="line">        <span class="number">0X0209C004</span> <span class="number">0X04</span><span class="comment">/* GPIO1_GPIR_BASE */</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="十、驱动使用设备树例子"><a href="#十、驱动使用设备树例子" class="headerlink" title="十、驱动使用设备树例子"></a>十、驱动使用设备树例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 入口和出口函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">dtsof_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> = <span class="title">NULL</span>;</span> <span class="comment">// 节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property</span> *<span class="title">comppro</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">u32 def_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> elesize = <span class="number">0</span>;</span><br><span class="line">u32 *brival;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 找到backlight节点 */</span></span><br><span class="line">np = of_find_node_by_path(<span class="string">"/backlight"</span>);</span><br><span class="line"><span class="keyword">if</span> (np == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取属性 */</span></span><br><span class="line">comppro = of_find_property(np, <span class="string">"compatible"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (comppro == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_findpro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"compatible=%s\r\n"</span>, (<span class="keyword">char</span> *)comppro-&gt;value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = of_property_read_string(np, <span class="string">"status"</span>, &amp;str);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"status=%s\r\n"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3 获取数字属性值 */</span></span><br><span class="line">ret = of_property_read_u32(np, <span class="string">"default-brightness-level"</span>, &amp;def_value);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_read_u32;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"default-brightness-level = %d\r\n"</span>, def_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取数组类型的属性 */</span></span><br><span class="line">elesize = of_property_count_elems_of_size(np, <span class="string">"brightness-levels"</span>, <span class="keyword">sizeof</span>(u32));</span><br><span class="line"><span class="keyword">if</span> (elesize &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_readele;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"brightness-levels elems size = %d\r\n"</span>, elesize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 申请内存 */</span></span><br><span class="line">brival = kmalloc(elesize * <span class="keyword">sizeof</span>(u32), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!brival)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取数组 */</span></span><br><span class="line">ret = of_property_read_u32_array(np, <span class="string">"brightness-levels"</span>, brival, elesize);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_read32array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; elesize; i++)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"brightness-levels[%d] = %d \r\n"</span>, i, brival[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">kfree(brival);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">fail_read32array:</span><br><span class="line">kfree(brival);<span class="comment">/* 释放内存 */</span></span><br><span class="line">fail_mem:</span><br><span class="line">fail_readele:</span><br><span class="line">fail_read_u32:</span><br><span class="line">fail_rs:</span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line">fail_findpro:</span><br><span class="line">fail_findnd:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">dtsof_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册入口和出口函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">module_init(dtsof_init);</span><br><span class="line">module_exit(dtsof_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><h2 id="十一、设备树下的LED驱动实验"><a href="#十一、设备树下的LED驱动实验" class="headerlink" title="十一、设备树下的LED驱动实验"></a>十一、设备树下的LED驱动实验</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DTSLED_CNT1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DTSLED_NAME<span class="meta-string">"dtsled"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDOFF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDON 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟地址的指针 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *GPIO1_DR;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> &#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> <span class="title">dtsled</span>;</span><span class="comment">/* LED设备 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_toggle</span><span class="params">(u8 state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(state == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 打开LED</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 关闭LED</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dtsled_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = &amp;dtsled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dtsled_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">dtsled_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> retvalue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtsled_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">retvalue = copy_from_user(databuff, buf, count);</span><br><span class="line"><span class="keyword">if</span> (retvalue &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"kernel write failed!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (databuff[<span class="number">0</span>] == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">led_toggle(LEDON);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">led_toggle(LEDOFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符操作设备集 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">dtsled_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">write</span> = dtsled_write,</span><br><span class="line">.<span class="built_in">open</span> = dtsled_open,</span><br><span class="line">.<span class="built_in">release</span> = dtsled_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 入口和出口 */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">dtsled_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">u32 regdata[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.注册字符设备 */</span></span><br><span class="line"><span class="comment">/* 1.1 申请设备号 */</span></span><br><span class="line">dtsled.major = <span class="number">0</span>;<span class="comment">/* 设备号由内核分配 */</span></span><br><span class="line"><span class="keyword">if</span> (dtsled.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 定义了设备号 */</span></span><br><span class="line">dtsled.devid = MKDEV(dtsled.major,<span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(dtsled.devid, DTSLED_CNT, DTSLED_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 没有给定设备号,向内核申请*/</span></span><br><span class="line">ret = alloc_chrdev_region(&amp;dtsled.devid, <span class="number">0</span>, DTSLED_CNT, DTSLED_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.1 添加字符设备 */</span></span><br><span class="line">dtsled.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;dtsled.cdev, &amp;dtsled_fops);</span><br><span class="line">ret = cdev_add(&amp;dtsled.cdev, dtsled.devid, DTSLED_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.自动创建设备节点 */</span></span><br><span class="line"><span class="comment">/* 3.1 创建类 */</span></span><br><span class="line">dtsled<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>,<span class="title">DTSLED_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dtsled.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(dtsled.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.2创建设备节点 */</span></span><br><span class="line">dtsled.device = device_create(dtsled.class, <span class="literal">NULL</span>, dtsled.devid, <span class="literal">NULL</span>, DTSLED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(dtsled.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(dtsled.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取设备树属性内容 */</span></span><br><span class="line">dtsled.nd = of_find_node_by_path(<span class="string">"/alphaled"</span>);</span><br><span class="line"><span class="keyword">if</span> (dtsled.nd == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> fail_findnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = of_property_read_string(dtsled.nd, <span class="string">"status"</span>, &amp;str);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"status = %s\r\n"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = of_property_read_string(dtsled.nd, <span class="string">"compatible"</span>, &amp;str);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"compatible = %s\r\n"</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">ret = of_property_read_u32_array(dtsled.nd, <span class="string">"reg"</span>, regdata, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"red data："</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"%#x "</span>, regdata[i]);</span><br><span class="line">&#125;</span><br><span class="line">printk(<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED初始化 */</span></span><br><span class="line"><span class="comment">/* 地址映射 */</span></span><br><span class="line"></span><br><span class="line">CCM_CCGR1 = ioremap(regdata[<span class="number">0</span>], regdata[<span class="number">1</span>]);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(regdata[<span class="number">2</span>], regdata[<span class="number">3</span>]);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(regdata[<span class="number">4</span>], regdata[<span class="number">5</span>]);</span><br><span class="line">GPIO1_DR = ioremap(regdata[<span class="number">6</span>], regdata[<span class="number">7</span>]);</span><br><span class="line">GPIO1_GDIR = ioremap(regdata[<span class="number">8</span>], regdata[<span class="number">9</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* 使用of_iomap直接获取地址映射 */</span></span><br><span class="line">CCM_CCGR1 = of_iomap(dtsled.nd, <span class="number">0</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">1</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = of_iomap(dtsled.nd, <span class="number">2</span>);</span><br><span class="line">GPIO1_DR = of_iomap(dtsled.nd, <span class="number">3</span>);</span><br><span class="line">GPIO1_GDIR = of_iomap(dtsled.nd, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);<span class="comment">// 使能时钟</span></span><br><span class="line"></span><br><span class="line">writel(<span class="number">0x5</span>, SW_MUX_GPIO1_IO03);<span class="comment">// 设置复用</span></span><br><span class="line">writel(<span class="number">0x10b0</span>, SW_PAD_GPIO1_IO03);<span class="comment">// 设置电气属性</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);<span class="comment">// 设置输出</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 默认打开LED</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_rs:</span><br><span class="line">fail_findnd:</span><br><span class="line">device_destroy(dtsled.class, dtsled.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(dtsled.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;dtsled.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(dtsled.devid, DTSLED_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">dtsled_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 取消地址映射 */</span></span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 摧毁设备 */</span></span><br><span class="line">device_destroy(dtsled.class, dtsled.devid);</span><br><span class="line"><span class="comment">/* 摧毁类 */</span></span><br><span class="line">class_destroy(dtsled.class);</span><br><span class="line"><span class="comment">/* 删除字符设备 */</span></span><br><span class="line">cdev_del(&amp;dtsled.cdev);</span><br><span class="line"><span class="comment">/* 释放设备号 */</span></span><br><span class="line">unregister_chrdev_region(dtsled.devid, DTSLED_CNT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册驱动和卸载驱动 */</span></span><br><span class="line">module_init(dtsled_init);</span><br><span class="line">module_exit(dtsled_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><h2 id="十二、测试应用程序"><a href="#十二、测试应用程序" class="headerlink" title="十二、测试应用程序"></a>十二、测试应用程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ./ledAPP &lt;filename&gt; &lt;0:1&gt; 1 表示开灯 0 表示关灯</span></span><br><span class="line"><span class="comment"> * @param argc 应用程序参数个数</span></span><br><span class="line"><span class="comment"> * @param argv 保存的参数，字符串形式。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( argc !=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入错误\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: %s\r\n"</span>,filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读 */</span></span><br><span class="line"><span class="comment">/* if (atoi(argv[2]) ==1 )// 传递过来的是字符串，需要转换成数字</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ret = read(fd, readbuf, 10);</span></span><br><span class="line"><span class="comment">if (ret &lt; 0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("read file %s failed\r\n", filename);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line">databuff[<span class="number">0</span>] = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写 */</span></span><br><span class="line">ret = <span class="built_in">write</span>(fd, databuff, <span class="keyword">sizeof</span>(databuff));</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"LED control failed!\r\n"</span>);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 */</span></span><br><span class="line">ret = <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（四）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.html</id>
    <published>2020-09-19T13:48:02.000Z</published>
    <updated>2020-12-19T14:22:45.309Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="一、新字符设备驱动原理（相比于上一篇笔记）"><a href="#一、新字符设备驱动原理（相比于上一篇笔记）" class="headerlink" title="一、新字符设备驱动原理（相比于上一篇笔记）"></a>一、新字符设备驱动原理（相比于上一篇笔记）</h2><ol><li><p>以前的缺点：</p><p>使用 <code>register_chrdev</code> 函数注册字符设备，会浪费很多次设备号，而且需要手动指定。</p></li><li><p>新的方法：</p><p>使用 <code>alloc_chrdev_region</code> 函数申请设备号。原型如下：</p><a id="more"></a></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure><p>卸载驱动的时候，使用 <code>unregister_chrdev_region</code> 函数释放前面申请的设备号，原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unregister_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count)</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>指定设备号</p><p>如果指定主设备号，使用 <code>register_chrdev_region</code> 函数来注册，原型如下：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> from, <span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure><pre><code>一般是给定主设备号，然后使用 `MADEV` 构建完整的 `dev_t` ，一般次设备号选择`0`。</code></pre><ol start="4"><li><p>实际的驱动编写</p><p>需要考虑实际情况，因为在实际开发中会有两种情况：给定设备号和没有给定设备号。</p></li><li><p>字符设备注册</p><p><code>cdev</code> 结构体表示字符设备，然后使用 <code>cdev_init</code> 函数来初始化 <code>cdev</code> ，原型</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cdev_init(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span><br></pre></td></tr></table></figure><p>​ <code>cdev_init</code> 初始化完成 <code>cdev</code> 后，使用 <code>cdev_add</code> 添加到Linux内核，删除字符设备使用 <code>cdev_del</code> 。</p><h2 id="二、自动创建设备节点"><a href="#二、自动创建设备节点" class="headerlink" title="二、自动创建设备节点"></a>二、自动创建设备节点</h2><ol><li>linux内核在2.6版本中引入了 <code>udev</code> 机制，替换<code>devfs</code> 。<code>udev</code> 机制提供热插拔管理，可以在加载驱动的时候自动创建 <code>/dev/xxx</code> 设备文件。</li><li>在使用busybox构建根文件系统的时候，busybox会创建一个 <code>udev</code> 的简化版本 <code>mdev</code> ，所以在嵌入式linux中使用 <code>mdev</code> 来实现设备节点文件的自动创建和删除。linux系统中的热插拔事件也由 <code>mdev</code> 管理，在 <code>/etc/init.d/rsS</code> 文件中如下语句。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11 <span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">12 mdev -s</span><br></pre></td></tr></table></figure><ol start="3"><li><p>创建设备节点<br>3.1. 创建设备类</p><p>创建设备节点需要先使用<code>class_create()</code> 函数创建类。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建类 */</span></span><br><span class="line">newChrLed<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">LED_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newChrLed.class))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(newChrLed.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.2. 创建设备节点</p><p>使用 <code>device_create()</code> 函数来创建设备节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">newChrLed.device = device_create(newChrLed.class, <span class="literal">NULL</span>, newChrLed.devid, <span class="literal">NULL</span>, LED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newChrLed.device))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PTR_ERR(newChrLed.device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁设备节点和类</p><p>在驱动卸载的时候，需要对设备节点进行销毁。在驱动出口函数中使用如下代码进行销毁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 摧毁设备节点 */</span></span><br><span class="line">device_destroy(newChrLed.class, newChrLed.devid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 摧毁类 */</span></span><br><span class="line">class_destroy(newChrLed.class);</span><br></pre></td></tr></table></figure></li></ol><p>​ <strong>因为创建设备节点是根据类来创建的，因此在销毁时，需要先销毁设备节点再销毁类。</strong></p><h2 id="三、文件私有数据"><a href="#三、文件私有数据" class="headerlink" title="三、文件私有数据"></a>三、文件私有数据</h2><ol><li>在 <code>open</code> 函数里设置 <code>filp-&gt;private_data</code> 为设备变量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置私有数据 */</span></span><br><span class="line">filp-&gt;private_data= &amp;newChrLed;</span><br></pre></td></tr></table></figure><ol start="2"><li>在其他的函数里，要访问设备的时候，直接读取私有数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newChrLed_dev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br></pre></td></tr></table></figure><h2 id="四、错误处理"><a href="#四、错误处理" class="headerlink" title="四、错误处理"></a>四、错误处理</h2><p>​ 在 <code>xxx_init</code> 加载驱动出现错误的时候，可以使用 <code>goto</code> 语句，对错误进行处理。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">newChrLed.cdev.owner = THIS_MODULE;</span><br><span class="line">ret = cdev_init(&amp;newChrLed.cdev, &amp;newChrLed_fops);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = cdev_add(&amp;newChrLed.cdev, newChrLed.devid, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fail_cdev:</span><br><span class="line"><span class="comment">/* 删除字符设备 */</span></span><br><span class="line">cdev_del(&amp;newChrLed.cdev);</span><br><span class="line"><span class="comment">/* 因为cdev初始化失败，所以需要注销设备号 */</span></span><br><span class="line">unregister_chrdev_region(newChrLed.devid, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h2 id="五、整体程序（开发中不使用这种方式）"><a href="#五、整体程序（开发中不使用这种方式）" class="headerlink" title="五、整体程序（开发中不使用这种方式）"></a>五、整体程序（开发中不使用这种方式）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_NAME<span class="meta-string">"LED"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寄存器物理地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟地址的指针 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *GPIO1_DR;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDOFF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDON 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LED设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">newChrLed_dev</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">// cdev</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">// 设备号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">// 设备</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">// 主设备号</span></span><br><span class="line"><span class="keyword">int</span> minor;<span class="comment">// 次设备号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">newChrLed_dev</span> <span class="title">newChrLed</span>;</span><span class="comment">// LED设备</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_toggle</span><span class="params">(u8 state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(state == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 打开LED</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 关闭LED</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newchrled_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 设置私有数据 */</span></span><br><span class="line">filp-&gt;private_data= &amp;newChrLed;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">newchrled_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">filp-&gt;private_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">newchrled_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> * off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> retvalue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line"><span class="comment">// struct newChrLed_dev *dev = filp-&gt;private_data;</span></span><br><span class="line">retvalue = copy_from_user(databuff, buf, len);</span><br><span class="line"><span class="keyword">if</span> (retvalue &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"kernel write failed!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (databuff[<span class="number">0</span>] == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">led_toggle(LEDON);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">led_toggle(LEDOFF);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">newChrLed_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">write</span> = newchrled_write,</span><br><span class="line">.<span class="built_in">open</span> = newchrled_open,</span><br><span class="line">.<span class="built_in">release</span> = newchrled_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">newchrled_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 1.初始化LED */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 初始化LED灯，地址映射 */</span></span><br><span class="line">CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);<span class="comment">// 使能时钟</span></span><br><span class="line"></span><br><span class="line">writel(<span class="number">0x5</span>, SW_MUX_GPIO1_IO03);<span class="comment">// 设置复用</span></span><br><span class="line">writel(<span class="number">0x10b0</span>, SW_PAD_GPIO1_IO03);<span class="comment">// 设置电气属性</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);<span class="comment">// 设置输出</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 默认打开LED</span></span><br><span class="line"></span><br><span class="line">newChrLed.major = <span class="number">0</span>;<span class="comment">// 设置为0，表示由系统自动分配设备号</span></span><br><span class="line"><span class="comment">/* 2.注册字符设备 */</span></span><br><span class="line"><span class="keyword">if</span> (newChrLed.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 给定主设备号</span></span><br><span class="line">newChrLed.devid = MKDEV(newChrLed.major, <span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(newChrLed.devid, <span class="number">1</span>, LED_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 没有给定主设备号</span></span><br><span class="line">ret = alloc_chrdev_region(&amp;newChrLed.devid, <span class="number">0</span>, <span class="number">1</span>, LED_NAME);</span><br><span class="line">newChrLed.major = MAJOR(newChrLed.devid);</span><br><span class="line">newChrLed.minor = MINOR(newChrLed.devid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"newchrled chrdev_region error!\r\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">"newchrled major = %d, minor = %de\r\n"</span>, newChrLed.major, newChrLed.minor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.字符设备注册 */</span></span><br><span class="line">newChrLed.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;newChrLed.cdev, &amp;newChrLed_fops);</span><br><span class="line">ret = cdev_add(&amp;newChrLed.cdev, newChrLed.devid, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4.自动创建设备节点 */</span></span><br><span class="line"><span class="comment">/* 创建类 */</span></span><br><span class="line">newChrLed<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">LED_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newChrLed.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(newChrLed.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 创建设备节点 */</span></span><br><span class="line">newChrLed.device = device_create(newChrLed.class, <span class="literal">NULL</span>, newChrLed.devid, <span class="literal">NULL</span>, LED_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(newChrLed.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(newChrLed.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(newChrLed.class);</span><br><span class="line"></span><br><span class="line">fail_class:</span><br><span class="line"><span class="comment">/* 删除字符设备 */</span></span><br><span class="line">cdev_del(&amp;newChrLed.cdev);</span><br><span class="line"></span><br><span class="line">fail_cdev:</span><br><span class="line"><span class="comment">/* 因为cdev初始化失败，所以需要注销设备号 */</span></span><br><span class="line">unregister_chrdev_region(newChrLed.devid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">newchrled_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 取消地址映射 */</span></span><br><span class="line">iounmap(IMX6U_CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 删除字符设备 */</span></span><br><span class="line">cdev_del(&amp;newChrLed.cdev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销设备号 */</span></span><br><span class="line">unregister_chrdev_region(newChrLed.devid, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 摧毁设备 */</span></span><br><span class="line">device_destroy(newChrLed.class, newChrLed.devid);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 摧毁类 */</span></span><br><span class="line">class_destroy(newChrLed.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册入口和出口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">module_init(newchrled_init);</span><br><span class="line">module_exit(newchrled_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"fengyuhang"</span>);</span><br></pre></td></tr></table></figure><h2 id="六、测试应用程序"><a href="#六、测试应用程序" class="headerlink" title="六、测试应用程序"></a>六、测试应用程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ./ledAPP &lt;filename&gt; &lt;0:1&gt; 1 表示开灯 0 表示关灯</span></span><br><span class="line"><span class="comment"> * @param argc 应用程序参数个数</span></span><br><span class="line"><span class="comment"> * @param argv 保存的参数，字符串形式。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( argc !=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入错误\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: %s\r\n"</span>,filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读 */</span></span><br><span class="line"><span class="comment">/* if (atoi(argv[2]) == 1)// 传递过来的是字符串，需要转换成数字</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ret = read(fd, readbuf, 10);</span></span><br><span class="line"><span class="comment">if (ret &lt; 0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("read file %s failed\r\n", filename);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line">databuff[<span class="number">0</span>] = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写 */</span></span><br><span class="line">ret = <span class="built_in">write</span>(fd, databuff, <span class="keyword">sizeof</span>(databuff));</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"LED control failed!\r\n"</span>);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 */</span></span><br><span class="line">ret = <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（三）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89.html</id>
    <published>2020-09-19T13:44:12.000Z</published>
    <updated>2020-12-18T15:03:10.474Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="一、地址映射"><a href="#一、地址映射" class="headerlink" title="一、地址映射"></a>一、地址映射</h2><ol><li><p>因为<code>linux</code>使用<code>MMC</code>，因此在驱动开发时，不能直接对寄存器物理地址进行读写操作。</p></li><li><p>在<code>linux</code>里面操作的都是虚拟地址，所以需要先得到物理地址对应的虚拟地址。获得物理地址对应的虚拟地址使用<code>va = ioremap(cookie,size)</code>函数，第一个参数是物理地址起始地址，第二个参数就是要转换的字节数量，返回的是申请到的虚拟地址。卸载驱动的时候使用<code>iounmap(va)</code>；</p><a id="more"></a></li><li><p>操作虚拟地址时使用</p><ul><li><code>readb(const volatile void __iomem *addr)</code> 8bit</li><li><code>readw(const volatile void __iomem *addr)</code> 16bit</li><li><code>readl(const volatile void __iomem *addr)</code> 32bit</li><li><code>writeb(u8 value,volatile void __iomem *addr)</code> 8bit</li><li><code>writew(u16 value, volatile void __iomem *addr)</code> 16bit</li><li><code>writel(u32 value, volatile void __iomem *addr)</code> 32bit</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 出口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 初始化LED灯，地址映射 */</span></span><br><span class="line">CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);<span class="comment">// 使能时钟</span></span><br><span class="line"></span><br><span class="line">writel(<span class="number">0x5</span>, SW_MUX_GPIO1_IO03);<span class="comment">// 设置复用</span></span><br><span class="line">writel(<span class="number">0x10b0</span>, SW_PAD_GPIO1_IO03);<span class="comment">// 设置电气属性</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);<span class="comment">// 设置输出</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 默认打开LED</span></span><br><span class="line"></span><br><span class="line">ret = register_chrdev(LED_MAJOR, LED_NAME, &amp;led_fops);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"led_init failed! \r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">"led_init\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 出口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">led_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 取消地址映射 */</span></span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备 */</span></span><br><span class="line">unregister_chrdev(LED_MAJOR,LED_NAME);</span><br><span class="line">printk(<span class="string">"led_exit\r\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、驱动程序编写（正常开发中不使用这种方式）"><a href="#二、驱动程序编写（正常开发中不使用这种方式）" class="headerlink" title="二、驱动程序编写（正常开发中不使用这种方式）"></a>二、驱动程序编写（正常开发中不使用这种方式）</h2><ol><li>初始化时钟、IO、GPIO等。</li><li><strong>如果要在卸载驱动时关闭LED，一定要在取消地址映射前操作LED。</strong></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/mach/map.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_MAJOR100<span class="comment">// 主设备号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LED_NAME<span class="meta-string">"LED"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寄存器物理地址 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CCM_CCGR1_BASE(0X020C406C)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SW_MUX_GPIO1_IO03_BASE(0X020E0068)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SW_PAD_GPIO1_IO03_BASE(0X020E02F4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO1_GDIR_BASE(0X0209C004)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO1_DR_BASE(0X0209C000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 虚拟地址的指针 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *CCM_CCGR1;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *SW_MUX_GPIO1_IO03;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *SW_PAD_GPIO1_IO03;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *GPIO1_GDIR;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __iomem *GPIO1_DR;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDOFF0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEDON 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">led_toggle</span><span class="params">(u8 state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u32 val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(state == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 打开LED</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 关闭LED</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">led_release</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">led_write</span><span class="params">(struct file * fp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> len, <span class="keyword">loff_t</span> * off)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> retvalue;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line">retvalue = copy_from_user(databuff, buf, len);</span><br><span class="line"><span class="keyword">if</span> (retvalue &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"kernel write failed!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (databuff[<span class="number">0</span>] == LEDON)</span><br><span class="line">&#123;</span><br><span class="line">led_toggle(LEDON);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">led_toggle(LEDOFF);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 字符设备操作集 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">led_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">write</span> = led_write,</span><br><span class="line">.<span class="built_in">open</span> = led_open,</span><br><span class="line">.<span class="built_in">release</span> = led_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 模块入口函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">led_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 初始化LED灯，地址映射 */</span></span><br><span class="line">CCM_CCGR1 = ioremap(CCM_CCGR1_BASE, <span class="number">4</span>);</span><br><span class="line">SW_MUX_GPIO1_IO03 = ioremap(SW_MUX_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">SW_PAD_GPIO1_IO03 = ioremap(SW_PAD_GPIO1_IO03_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_GDIR = ioremap(GPIO1_GDIR_BASE, <span class="number">4</span>);</span><br><span class="line">GPIO1_DR = ioremap(GPIO1_DR_BASE, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 */</span></span><br><span class="line">val = readl(CCM_CCGR1);</span><br><span class="line">val &amp;= ~(<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">val |= (<span class="number">3</span> &lt;&lt; <span class="number">26</span>);</span><br><span class="line">writel(val, CCM_CCGR1);<span class="comment">// 使能时钟</span></span><br><span class="line"></span><br><span class="line">writel(<span class="number">0x5</span>, SW_MUX_GPIO1_IO03);<span class="comment">// 设置复用</span></span><br><span class="line">writel(<span class="number">0x10b0</span>, SW_PAD_GPIO1_IO03);<span class="comment">// 设置电气属性</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_GDIR);</span><br><span class="line">val |= (<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_GDIR);<span class="comment">// 设置输出</span></span><br><span class="line"></span><br><span class="line">val = readl(GPIO1_DR);</span><br><span class="line">val &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">writel(val, GPIO1_DR);<span class="comment">// 默认打开LED</span></span><br><span class="line"></span><br><span class="line">ret = register_chrdev(LED_MAJOR, LED_NAME, &amp;led_fops);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"led_init failed! \r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printk(<span class="string">"led_init\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 出口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">led_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 如果要在卸载驱动时关闭LED，一定要在取消地址映射前操作LED */</span></span><br><span class="line"><span class="comment">/* 取消地址映射 */</span></span><br><span class="line">iounmap(CCM_CCGR1);</span><br><span class="line">iounmap(SW_MUX_GPIO1_IO03);</span><br><span class="line">iounmap(SW_PAD_GPIO1_IO03);</span><br><span class="line">iounmap(GPIO1_GDIR);</span><br><span class="line">iounmap(GPIO1_DR);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注销字符设备 */</span></span><br><span class="line">unregister_chrdev(LED_MAJOR,LED_NAME);</span><br><span class="line">printk(<span class="string">"led_exit\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 驱动的加载和卸载</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">module_init(led_init);</span><br><span class="line">module_exit(led_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><h2 id="三、应用程序编写"><a href="#三、应用程序编写" class="headerlink" title="三、应用程序编写"></a>三、应用程序编写</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ./ledAPP &lt;filename&gt; &lt;0:1&gt; 1 表示开灯 0 表示关灯</span></span><br><span class="line"><span class="comment"> * @param argc 应用程序参数个数</span></span><br><span class="line"><span class="comment"> * @param argv 保存的参数，字符串形式。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> databuff[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( argc !=<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入错误\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error: %s\r\n"</span>,filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读 */</span></span><br><span class="line"><span class="comment">/* if (atoi(argv[2]) ==1 )// 传递过来的是字符串，需要转换成数字</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ret = read(fd, readbuf, 10);</span></span><br><span class="line"><span class="comment">if (ret &lt; 0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("read file %s failed\r\n", filename);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line">databuff[<span class="number">0</span>] = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 写 */</span></span><br><span class="line">ret = <span class="built_in">write</span>(fd, databuff, <span class="keyword">sizeof</span>(databuff));</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"LED control failed!\r\n"</span>);</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 */</span></span><br><span class="line">ret = <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><ol><li>先输入 <code>depmod</code>。</li><li>然后输入 <code>modprobe led.ko</code> 加载驱动</li><li>再输入 <code>mknod /dev/led</code> 创建设备节点</li><li>输入 <code>./ledAPP /dev/led 0</code> 或 <code>./ledAPP /dev/led 1</code> 来点亮和关闭 <code>led</code> 。</li></ol>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（二）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89.html</id>
    <published>2020-09-19T13:40:24.000Z</published>
    <updated>2020-12-19T14:52:03.032Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="一、字符设备驱动"><a href="#一、字符设备驱动" class="headerlink" title="一、字符设备驱动"></a>一、字符设备驱动</h2><p>字符设备驱动的编写主要就是驱动对应的<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>函数。其实就是file_operations结构体的成员变量的实现。</p><h2 id="二、驱动模块的加载与卸载"><a href="#二、驱动模块的加载与卸载" class="headerlink" title="二、驱动模块的加载与卸载"></a>二、驱动模块的加载与卸载</h2><p>Linux驱动程序可以编译到kernel里面，也就是zImage，也可以编译为模块(.ko)。测试的时候只需要加载.ko模块就行。</p><ul><li><code>module_init(xxx_init);</code> //注册模块加载函数</li><li><code>module_exit(xxx_exit)</code> //注册模块卸载函数</li></ul><a id="more"></a><p>编写驱动的时候注意事项！</p><ol><li><p>编译驱动的时候需要用到<code>linux</code>内核源码！因此需要解压缩<code>linux</code>源码，编译<code>linux</code>内核源码。得到<code>zImage</code>和<code>dtb</code>。需要使用编译后得到的<code>zImage</code>和<code>dtb</code>启动系统。</p><p><code>vscode</code>中设置<code>linux</code>源码所在路径，<code>.vscode/c_cpp_properties.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Linux"</span>,</span><br><span class="line">            <span class="attr">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/**"</span>,</span><br><span class="line">                <span class="string">"/home/rabbit/linux/IMX6UL/linux_image/linux-imx-alientek/include"</span>, </span><br><span class="line">                <span class="string">"/home/rabbit/linux/IMX6UL/linux_image/linux-imx-alientek/arch/arm/include"</span>, </span><br><span class="line">                <span class="string">"/home/rabbit/linux/IMX6UL/linux_image/linux-imx-alientek/arch/arm/include/generated/"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defines"</span>: [],</span><br><span class="line">            <span class="attr">"compilerPath"</span>: <span class="string">"/usr/bin/gcc"</span>,</span><br><span class="line">            <span class="attr">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">            <span class="attr">"cppStandard"</span>: <span class="string">"c++17"</span>,</span><br><span class="line">            <span class="attr">"intelliSenseMode"</span>: <span class="string">"clang-x64"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makefile</code>内容</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内核路径</span></span><br><span class="line">KERNELDIR := /home/rabbit/linux/IMX6UL/linux_image/linux-imx-alientek</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前路径</span></span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件</span></span><br><span class="line">obj-m := chrdevbase.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规则</span></span><br><span class="line">build : kernel_modules</span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure></li><li><p>将编译出来的<code>.ko</code>文件放到根文件系统中。加载驱动会用到加载命令：<code>insmod</code>，<code>modprobe</code>。移除驱动使用命令：<code>rmmod</code>，查看加载的驱动模块命令：<code>lsmod</code>。</p><ul><li><code>insmod</code>：不会解决模块的依赖关系。</li><li><code>modprobe</code>：可以处理模块的依赖关系。<strong>推荐使用</strong>，<code>modprobe</code>会到<code>/lib/modules/内核版本</code>下查找相应的驱动模块。</li></ul><p>==对于一个新的模块使用<code>modprode</code>加载的时候需要先调用一下<code>depmod</code>命令来分析可载入模块的相依性。==</p></li></ol><h2 id="三、字符设备的注册与注销"><a href="#三、字符设备的注册与注销" class="headerlink" title="三、字符设备的注册与注销"></a>三、字符设备的注册与注销</h2><ol><li><p>我们需要向系统注册一个字符设备，使用函数（即将弃用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> init <span class="title">register_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> struct file_operations *fops)</span></span></span><br></pre></td></tr></table></figure></li><li><p>卸载驱动的时候需要注销掉前面注册的字符设备，使用函数（即将弃用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unregister_chrdev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> major, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>major</code>：主设备号，linux下每个设备都有一个设备号，设备号分为主设备号和次设备号两个部分。传入<code>0</code>自动分配。</li><li><code>name</code>：设备名字，指向一串字符串。</li><li><code>fops</code>：结构体<code>file_operations</code>类型指针，指向设备的操作函数集合变量。</li></ul></li></ol><h2 id="四、设备号"><a href="#四、设备号" class="headerlink" title="四、设备号"></a>四、设备号</h2><ol><li><p>linux内核使用<code>dev_t</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_dev_t</span><span class="keyword">dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> __u32 <span class="keyword">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __u32;</span><br></pre></td></tr></table></figure><p>其中 <code>dev_t</code> 是一个无符号32位整型数据，其中高12位为主设备号(0～4096，表示同一类设备，比如IIC设备)，低20位为次设备号。</p></li><li><p>设备号的操作函数或宏</p><p>从<code>dev_t</code>获取主设备号和次设备号，<code>MAJOR(dev_t)</code>，<code>MINOR(dev_t)</code>，也可以使用主设备号和次设备号构成<code>dev_t</code>，通过<code>MKDE(major, minor)</code>即可。</p></li></ol><h2 id="五、file-operations的具体实现"><a href="#五、file-operations的具体实现" class="headerlink" title="五、file_operations的具体实现"></a>五、file_operations的具体实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*<span class="built_in">read</span>) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*<span class="built_in">write</span>) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line"><span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*poll)</span> <span class="params">(struct file *, struct poll_table_struct *)</span></span>;</span><br><span class="line"><span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line"><span class="keyword">int</span> (*mremap)(struct file *, struct vm_area_struct *);</span><br><span class="line"><span class="keyword">int</span> (*<span class="built_in">open</span>) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">int</span> (*<span class="built_in">flush</span>) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line"><span class="keyword">int</span> (*<span class="built_in">release</span>) (struct inode *, struct file *);</span><br><span class="line"><span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line"><span class="keyword">int</span> (*aio_fsync) (struct kiocb *, <span class="keyword">int</span> datasync);</span><br><span class="line"><span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line"><span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">  <span class="keyword">loff_t</span> len);</span><br><span class="line"><span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="六、字符设备驱动框架"><a href="#六、字符设备驱动框架" class="headerlink" title="六、字符设备驱动框架"></a>六、字符设备驱动框架</h2><p>多借鉴别人的驱动程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ide.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_address.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/of_irq.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHRDEVBASE_NAME<span class="meta-string">"chrdevbase"</span><span class="comment">// 名字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHRDEVBASE_CNT1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设备结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">dev_t</span> devid;<span class="comment">/* 设备号 */</span></span><br><span class="line"><span class="keyword">int</span> major;<span class="comment">/* 主设备号 */</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cdev</span>;</span><span class="comment">/* 字符设备 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *<span class="title">class</span>;</span><span class="comment">/* 类 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* 设备节点 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">nd</span>;</span><span class="comment">/* 设备树节点 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chrdev</span> <span class="title">chrdevbase</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdevbase_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filp-&gt;private_data = &amp;chrdevbase;</span><br><span class="line">printk(<span class="string">"chrdevbase_open!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdevbase_close</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chrdev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">printk(<span class="string">"chrdevbase_close!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrdevbase_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chrdev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">printk(<span class="string">"chrdevbase_read!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrdevbase_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">chrdev</span> *<span class="title">dev</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">printk(<span class="string">"chrdevbase_write!"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrdevbase_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = chrdevbase_open,</span><br><span class="line">.<span class="built_in">release</span> = chrdevbase_close,</span><br><span class="line">.<span class="built_in">read</span> = chrdevbase_read,</span><br><span class="line">.<span class="built_in">write</span> = chrdevbase_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">chrdevbase_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.注册字符设备 */</span></span><br><span class="line"><span class="comment">/* 1.1 申请设备号 */</span></span><br><span class="line">chrdevbase.major = <span class="number">0</span>;<span class="comment">/* 设备号由内核分配 */</span></span><br><span class="line"><span class="keyword">if</span> (chrdevbase.major)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 定义了设备号 */</span></span><br><span class="line">chrdevbase.devid = MKDEV(chrdevbase.major,<span class="number">0</span>);</span><br><span class="line">ret = register_chrdev_region(chrdevbase.devid, CHRDEVBASE_CNT, CHRDEVBASE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 没有给定设备号,向内核申请*/</span></span><br><span class="line">ret = alloc_chrdev_region(&amp;chrdevbase.devid, <span class="number">0</span>, CHRDEVBASE_CNT, CHRDEVBASE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_devid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.1 添加字符设备 */</span></span><br><span class="line">chrdevbase.cdev.owner = THIS_MODULE;</span><br><span class="line">cdev_init(&amp;chrdevbase.cdev, &amp;chrdevbase_fops);</span><br><span class="line">ret = cdev_add(&amp;chrdevbase.cdev, chrdevbase.devid, CHRDEVBASE_CNT);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> fail_cdev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.自动创建设备节点 */</span></span><br><span class="line"><span class="comment">/* 3.1 创建类 */</span></span><br><span class="line">chrdevbase<span class="class">.<span class="keyword">class</span> = <span class="title">class_create</span>(<span class="title">THIS_MODULE</span>, <span class="title">CHRDEVBASE_NAME</span>);</span></span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chrdevbase.class))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(chrdevbase.class);</span><br><span class="line"><span class="keyword">goto</span> fail_class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3.2创建设备节点 */</span></span><br><span class="line">chrdevbase.device = device_create(chrdevbase.class, <span class="literal">NULL</span>, chrdevbase.devid, <span class="literal">NULL</span>, CHRDEVBASE_NAME);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(chrdevbase.device))</span><br><span class="line">&#123;</span><br><span class="line">ret = PTR_ERR(chrdevbase.device);</span><br><span class="line"><span class="keyword">goto</span> fail_device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail_findnd:</span><br><span class="line">device_destroy(chrdevbase.class, chrdevbase.devid);</span><br><span class="line">fail_device:</span><br><span class="line">class_destroy(chrdevbase.class);</span><br><span class="line">fail_class:</span><br><span class="line">cdev_del(&amp;chrdevbase.cdev);</span><br><span class="line">fail_cdev:</span><br><span class="line">unregister_chrdev_region(chrdevbase.devid, CHRDEVBASE_CNT);</span><br><span class="line">fail_devid:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">chrdevbase_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 摧毁设备节点 */</span></span><br><span class="line">device_destroy(chrdevbase.class, chrdevbase.devid);</span><br><span class="line"><span class="comment">/* 摧毁类 */</span></span><br><span class="line">class_destroy(chrdevbase.class);</span><br><span class="line"><span class="comment">/* 删除字符设备 */</span></span><br><span class="line">cdev_del(&amp;chrdevbase.cdev);</span><br><span class="line"><span class="comment">/* 释放设备号 */</span></span><br><span class="line">unregister_chrdev_region(chrdevbase.devid, CHRDEVBASE_CNT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模块入口与出口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">module_init(chrdevbase_init);<span class="comment">// 入口函数</span></span><br><span class="line">module_exit(chrdevbase_exit);<span class="comment">// 出口函数</span></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"XXXX"</span>);</span><br></pre></td></tr></table></figure><h2 id="七、编写应用程序"><a href="#七、编写应用程序" class="headerlink" title="七、编写应用程序"></a>七、编写应用程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ./chrdevbaseAPP &lt;filename&gt;</span></span><br><span class="line"><span class="comment"> * @param argc 应用程序参数个数</span></span><br><span class="line"><span class="comment"> * @param argv 保存的参数，字符串形式。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *filename;</span><br><span class="line"><span class="keyword">char</span> readbuf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> writebuf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">open</span>(filename, O_RDWR);</span><br><span class="line"><span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"can't open file %s\r\n"</span>,filename);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 读 */</span></span><br><span class="line">ret = <span class="built_in">read</span>(fd, readbuf, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"read file %s failed\r\n"</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 写 */</span></span><br><span class="line">ret = <span class="built_in">write</span>(fd, writebuf, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"write file %s failed\r\n"</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 关闭 */</span></span><br><span class="line">ret = <span class="built_in">close</span>(fd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"close file %s failed\r\n"</span>, filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、测试"><a href="#八、测试" class="headerlink" title="八、测试"></a>八、测试</h2><ol><li><p>加载驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe chrdevbase.ko</span><br></pre></td></tr></table></figure></li><li><p>进入<code>/dev</code>查看设备文件，<code>chrdevbase</code>。但是由于没有创建设备节点<code>/dev/chrdevbase</code>并不会存在。这里使用<code>mknod /dev/chardevbase c 100 0</code>手动创建设备节点。</p></li><li><p>测试</p><p><code>./chrdevbaseAPP /dev/chrdevbase</code></p></li></ol><h2 id="九、完善chrdevbase虚拟字符设备驱动程序"><a href="#九、完善chrdevbase虚拟字符设备驱动程序" class="headerlink" title="九、完善chrdevbase虚拟字符设备驱动程序"></a>九、完善chrdevbase虚拟字符设备驱动程序</h2><ul><li>驱动给应用传递数据的时候需要用到<code>copy_to_user(to, from, n)</code>函数；</li><li>应用给驱动传递数据的时候需要用到<code>copy_from_user(to, from, n)</code>函数；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHRDEVBASE_MAJOR100<span class="comment">// 主设备号，0自动分配</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHRDEVBASE_NAME<span class="meta-string">"chrdevbase"</span><span class="comment">// 名字</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> readbuf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> writebuf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> kerneldata[] = &#123;<span class="string">"kernel data!"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdevbase_open</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"chrdevbase_open!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">chrdevbase_close</span><span class="params">(struct inode *inode, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"chrdevbase_close!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrdevbase_read</span><span class="params">(struct file *filp, <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* printk("chrdevbase_read!\r\n"); */</span></span><br><span class="line">ret = copy_to_user(buf, kerneldata, count);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ssize_t</span> <span class="title">chrdevbase_write</span><span class="params">(struct file *filp, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf, <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* printk("chrdevbase_write!\r\n"); */</span></span><br><span class="line">ret = copy_from_user(writebuf, buf, count);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"kernel recevdata:%s\r\n"</span>,writebuf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">chrdevbase_fops</span> = &#123;</span></span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.<span class="built_in">open</span> = chrdevbase_open,</span><br><span class="line">.<span class="built_in">release</span> = chrdevbase_close,</span><br><span class="line">.<span class="built_in">read</span> = chrdevbase_read,</span><br><span class="line">.<span class="built_in">write</span> = chrdevbase_write,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">chrdevbase_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">"chrdevbase_init\r\n"</span>);</span><br><span class="line"><span class="comment">/* 注册字符设备 */</span></span><br><span class="line">ret = register_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">"chrdevbase_init failed\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> __exit <span class="title">chrdevbase_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(<span class="string">"chrdevbase_exit\r\n"</span>);</span><br><span class="line">unregister_chrdev(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);</span><br><span class="line"><span class="comment">/* 注销字符设备 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模块入口与出口</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">module_init(chrdevbase_init);<span class="comment">// 入口函数</span></span><br><span class="line">module_exit(chrdevbase_exit);<span class="comment">// 出口函数</span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL嵌入式Linux驱动学习笔记（一）</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89.html</id>
    <published>2020-09-19T13:29:29.000Z</published>
    <updated>2020-12-18T15:03:55.571Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL嵌入式Linux驱动开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="一、应用程序和驱动的交互原理交互原理"><a href="#一、应用程序和驱动的交互原理交互原理" class="headerlink" title="一、应用程序和驱动的交互原理交互原理"></a>一、应用程序和驱动的交互原理交互原理</h2><p>驱动就是获取外设或者传感器数据，控制外设。数据会提交给应用程序。Linux下驱动编写既要编写一个驱动，还要编写一个简单的测试应用程序APP。单片机下驱动和应用都是放到一个文件里面，也就是杂糅到一起。Linux下驱动和应用是完全分开的。</p><a id="more"></a><ul><li><p>用户空间（用户态）和内核空间（内核态）</p><ul><li><p>Linux操作系统内核和驱动程序运行在内核空间，应用程序运行在用户空间，避免应用程序不正确的使用资源对系统产生危害。</p></li><li><p>应用程序想要访问内核资源有三种办法：系统调用、异常（中断）和陷入（软中断）。应用程序不会直接调用系统调用，而是通过API函数来间接的调用系统调用，比如<code>POSIX</code>、<code>API</code>和C库等。<code>unix</code>类操作系统种最常用的编程接口就是<code>POSIX</code>。</p></li><li><p>系统调用处于内核空间，应用程序无法直接访问，因此需要“陷入”到内核，方法就是软中断，陷入内核以后还要指定系统调用号。（每个系统调用都有一个系统调用号）。</p><p><img src="https://i.loli.net/2020/09/19/JfkY7L3mF98EhvT.png" alt="linux应用和驱动交互"></p></li><li><p>应用程序可以直接使用系统调用函数，比如：<code>open</code>、<code>close</code>等，也可以使用C库提供的函数。上图的左侧竖线表示直接使用系统调用，右侧竖线表示使用C库里面的函数，而C库里面的函数最终也是调用的系统调用函数。</p></li></ul></li></ul><h2 id="二、嵌入式驱动开发分类"><a href="#二、嵌入式驱动开发分类" class="headerlink" title="二、嵌入式驱动开发分类"></a>二、嵌入式驱动开发分类</h2><p>Linux驱动分为3大类：</p><ol><li>字符设备驱动，最多的。</li><li>块设备驱动，存储。</li><li>网络设备驱动。</li></ol><p>一个设备不一定只属于某一个类型。比如无线网卡，属于网络设备驱动，因为他又有<code>USB</code>和<code>SDIO</code>，因此也属于字符设备驱动。</p><h2 id="三、字符设备驱动开发"><a href="#三、字符设备驱动开发" class="headerlink" title="三、字符设备驱动开发"></a>三、字符设备驱动开发</h2><ul><li>Linux里面一切皆文件，驱动设备表现就是一个<code>/dev/</code>目录下的一个文件，比如<code>/dev/led</code>文件，应用程序调用<code>open</code>函数打开设备，比如led。应用程序通过<code>write</code>函数向<code>/dev/led</code>写数据，比如写1表示打开，写0代表关闭。如果关闭设备就是调用<code>close</code>函数。</li><li>编写驱动的时候也需要编写驱动对应的<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>函数。字符设备驱动<code>file_operation</code>结构体。</li></ul><ol><li>驱动最终是被应用调用的，在写驱动的时候要考虑应用开发的便利性。</li><li>驱动是分驱动框架的，要按照驱动框架来编写，对于字符设备驱动来说，重点编写应用程序对应的<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>等函数。</li></ol>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL嵌入式Linux开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="https://proudrabbit.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL学习笔记(七)</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83.html</id>
    <published>2020-09-18T15:14:24.000Z</published>
    <updated>2020-12-18T15:12:23.546Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL裸机开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="1-根文件系统简介"><a href="#1-根文件系统简介" class="headerlink" title="1. 根文件系统简介"></a>1. 根文件系统简介</h2><p>根文件系统就是一个特殊的”文件夹“，这个特殊的“文件夹”中保存着Linux运行所必须的，但是无法放入内核里面去。比如命令、库、配置文件等等。</p><a id="more"></a><h2 id="2-构建根文件系统"><a href="#2-构建根文件系统" class="headerlink" title="2. 构建根文件系统"></a>2. 构建根文件系统</h2><p>初学使用busybox来构建，做项目时使用成熟化的根文件系统构建方式，buildroot，yocto。</p><ol><li><p>修改Makefile，添加交叉编译器</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARCH ?= arm</span><br><span class="line"></span><br><span class="line">CROSS_COMPILE ?= /usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-g     nueabihf/bin/arm-linux-gnueabihf-</span><br></pre></td></tr></table></figure></li><li><p>修改busybox，添加中文字符支持</p><p>修改<code>libbb/printable_string.c</code>中的<code>printable_string</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c &lt; <span class="string">' '</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">/* if (c &gt;= 0x7f)</span></span><br><span class="line"><span class="comment">break; */</span></span><br><span class="line">s++;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == <span class="string">'\0'</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="string">' '</span>)</span><br><span class="line">    *d = <span class="string">'?'</span>;</span><br><span class="line">d++;</span><br></pre></td></tr></table></figure><p>修改<code>libbb/unicode.c</code>中的<code>unicode_conv_to_printable2</code>函数内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unicode_status != UNICODE_ON) &#123;</span><br><span class="line">    <span class="keyword">char</span> *d;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; UNI_FLAG_PAD) &#123;</span><br><span class="line">        d = dst = xmalloc(<span class="built_in">width</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> ((<span class="keyword">int</span>)--<span class="built_in">width</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> c = *src;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'\0'</span>) &#123;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                    *d++ = <span class="string">' '</span>;</span><br><span class="line">                <span class="keyword">while</span> ((<span class="keyword">int</span>)--<span class="built_in">width</span> &gt;= <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* *d++ = (c &gt;= ' ' &amp;&amp; c &lt; 0x7f) ? c : '?'; */</span></span><br><span class="line">            *d++ = (c &gt;= <span class="string">' '</span>) ? c : <span class="string">'?'</span>;</span><br><span class="line">            src++;</span><br><span class="line">        &#125;</span><br><span class="line">        *d = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        d = dst = xstrndup(src, <span class="built_in">width</span>);</span><br><span class="line">        <span class="keyword">while</span> (*d) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> c = *d;</span><br><span class="line">            <span class="comment">/* if (c &lt; ' ' || c &gt;= 0x7f) */</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="string">' '</span>)</span><br><span class="line">                *d = <span class="string">'?'</span>;</span><br><span class="line">            d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stats) &#123;</span><br><span class="line">        stats-&gt;byte_count = (d - dst);</span><br><span class="line">        stats-&gt;unicode_count = (d - dst);</span><br><span class="line">        stats-&gt;unicode_width = (d - dst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置busybox</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure><p>打开图形化界面，进行相关配置。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>然后编译busybox</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install CONFIG_PREFIX=/home/rabbit/linux/nfs/rootfs</span><br></pre></td></tr></table></figure></li><li><p>向根文件系统添加<code>lib</code>库文件</p><p>库文件是交叉编译器的库文件。</p><ul><li><p>将<code>/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux- gnueabihf/libc/lib</code>，<code>/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib</code>下的内容拷贝到<code>rootfs</code>下的<code>lib</code>文件夹内。</p></li><li><p>重新拷贝<code>ld-linux-armhf.so.3</code>文件到<code>rootfs</code>下的<code>lib</code>中，而不是上面拷贝的软链接文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ld-linux-armhf.so<span class="number">.3</span> /<span class="built_in">home</span>/zuozhongkai/linux/nfs/rootfs/lib/`</span><br></pre></td></tr></table></figure></li><li><p>拷贝<code>/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib</code>下的文件到<code>rootfs/usr/lib</code>下。</p></li><li><p>最后在根文件系统中创建其他文件夹,如 <code>dev</code>、<code>proc</code>、<code>mnt</code>、<code>sys</code>、<code>tmp</code> 和 <code>root</code> 等。</p></li></ul></li></ol><h2 id="3-根文件系统初步测试"><a href="#3-根文件系统初步测试" class="headerlink" title="3.根文件系统初步测试"></a>3.根文件系统初步测试</h2><p>​ 为了方便开发测试，使用<code>NFS</code>挂载测试。Linux内核文件中有说明命令行参数如何设置。要求：</p><ol><li>linux的内核网络驱动要工作正常。</li><li>设置uboot的<code>bootargs</code>，也就是linux内核的命令行参数。其中<code>ip</code>的参数为<code>本机地址:服务器地址:网关:子网掩码:[主机名]:网卡:自动配置</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs nfsroot&#x3D;192.168.1.102:&#x2F;home&#x2F;rabbit&#x2F;linux&#x2F;nfs&#x2F;rootfs,proto&#x3D;tcp rw ip&#x3D;192.168.1.170:192.168.1.102:192.168.1.1:255.255.255.0::eth0:off&#39;</span><br></pre></td></tr></table></figure><p>==如果挂载失败，显示如下信息==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VFS: Unable to mount root fs via NFS, trying floppy.</span><br><span class="line">VFS: Cannot open root device &quot;nfs&quot; or unknown-block(2,0): error -6</span><br></pre></td></tr></table></figure><p>修改<code>bootargs</code> 环境变量为以下的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs &#39;console&#x3D;ttymxc0,115200 root&#x3D;&#x2F;dev&#x2F;nfs nfsroot&#x3D;192.168.1.102:&#x2F;home&#x2F;rabbit&#x2F;linux&#x2F;nfs&#x2F;rootfs,nfsvers&#x3D;3,proto&#x3D;tcp rw ip&#x3D;192.168.1.170:192.168.1.102:192.168.1.1:255.255.255.0::eth0:off&#39;</span><br></pre></td></tr></table></figure><h2 id="4-完善根文件系统"><a href="#4-完善根文件系统" class="headerlink" title="4. 完善根文件系统"></a>4. 完善根文件系统</h2><p>由于出现以下错误，因此需要完善根文件系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">can&#39;t run &#39;&#x2F;etc&#x2F;init.d&#x2F;rcS&#39;: No such file or directory</span><br></pre></td></tr></table></figure><ol><li>创建<code>/etc/init.d/rcS</code> 写入以下内容</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:<span class="variable">$&#123;PATH&#125;</span></span><br><span class="line">LD_LIBRARY_PATH=<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>:/lib:/usr/lib</span><br><span class="line"><span class="built_in">export</span> PATH LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line">mount -a</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure><ol start="2"><li>创建<code>/etc/fstab</code>文件，写入以下内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#&lt;file system&gt; &lt;mount point&gt;&lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line">proc            &#x2F;proc           proc    defaults        0       0</span><br><span class="line">tmpfs           &#x2F;tmp            tmpfs   defaults        0       0</span><br><span class="line">sysfs           &#x2F;sys            sysfs   defaults        0       0</span><br><span class="line">tmpfs           &#x2F;dev            tmpfs   defaults        0       0</span><br></pre></td></tr></table></figure><ol start="3"><li>创建<code>/etc/inittab</code> 文件，写入如下内容</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#&#x2F;etc&#x2F;initable</span><br><span class="line">::sysinit:&#x2F;etc&#x2F;init.d&#x2F;rcS</span><br><span class="line">console::askfirst:-&#x2F;bin&#x2F;sh</span><br><span class="line">::restart:&#x2F;sbin&#x2F;init</span><br><span class="line">::ctrlaltdel:&#x2F;sbin&#x2F;reboot</span><br><span class="line">::shutdown:&#x2F;bin&#x2F;umount -a -r</span><br><span class="line">::shutdowm:&#x2F;sbin&#x2F;swapoff -a</span><br></pre></td></tr></table></figure><h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h2><ol><li>写个小程序测试下</li></ol><p><code>hello.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello-world\r\n"</span>);</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是运行在<code>ARM</code>上，所以需要使用交叉编译器编译这个<code>.c</code>文件，可以使用<code>file</code>命令来查看信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc hello.c -o hello</span><br></pre></td></tr></table></figure><ol start="2"><li>开机自启动</li></ol><p>在<code>/etc/init.d/rcS</code>添加开机自启动程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开机自启动</span></span><br><span class="line">/root/hello &amp;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>设置域名解析服务器地址（DNS）</p><p>新建<code>/etc/resolv.conf</code>，写入以下内容</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 192.168.1.1</span><br></pre></td></tr></table></figure><p>此时就可以<code>ping www.baidu.com</code>了。</p>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL裸机开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL学习笔记(六)</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD.html</id>
    <published>2020-09-18T15:11:20.000Z</published>
    <updated>2020-12-18T15:09:12.510Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL裸机开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="移植NXP官方的linux和设备树到开发板"><a href="#移植NXP官方的linux和设备树到开发板" class="headerlink" title="移植NXP官方的linux和设备树到开发板"></a>移植NXP官方的linux和设备树到开发板</h2><ol><li><p>首先使用默认配置文件，编译下测试linux能否在板子上运行。配置文件所在路径<code>arch/arm/configs/imx_v7_mfg_defconfig</code></p></li><li><p>通过修改NXP官方的默认配置文件和dtb配置文件，来适配开发板。</p><blockquote><p>imx_v7_mfg_defconfig</p><p>imx6ull-14x14-evk-emmc.dtb</p></blockquote></li></ol><a id="more"></a><ol start="3"><li><p>修改<code>arch/arm/boot/dts</code> 下的 <code>Makefile</code> 文件，将修改后的dtb文件，添加进去。</p><p>编译设备树文件，<code>make dtbs</code>。</p></li><li><p>修改主频和网络驱动（需要保证linux系统可以正常运行，因此需要暂时使用根文件系统）</p><ul><li>设置<code>bootcmd</code> 环境变量，使用 的是SD卡启动，镜像和设备树存放在SD卡中， <code>setenv bootcmd &#39;fatload mmc 0:1 80800000 zimage;fatload mmc 0:1 83000000 imx6ull-14x14-myboard.dtb;bootz 80800000 - 83000000;&#39;</code></li><li>设置<code>bootargs</code>，根文件系统存放在EMMC的分区2中，命令如下：<code>setenv bootargs &#39;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#39;</code></li><li>将<code>imx6ull-14x14-myboard.dts</code>中的<code>usdhc2</code>节点，改为以下内容。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pinctrl-names = <span class="string">"default"</span>, <span class="string">"state_100mhz"</span>, <span class="string">"state_200mhz"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_usdhc2_8bit&gt;;</span><br><span class="line">pinctrl<span class="number">-1</span> = &lt;&amp;pinctrl_usdhc2_8bit_100mhz&gt;;</span><br><span class="line">pinctrl<span class="number">-2</span> = &lt;&amp;pinctrl_usdhc2_8bit_200mhz&gt;;</span><br><span class="line">bus-<span class="built_in">width</span> = &lt;<span class="number">8</span>&gt;;</span><br><span class="line">non-removable;</span><br><span class="line">status = <span class="string">"okay"</span>;</span><br></pre></td></tr></table></figure><ul><li>然后使用<code>boot</code> 命令启动<code>linux</code>，至此启动完成。</li></ul></li><li><p>修改网络驱动。</p><p>修改dts文件对应位置代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_spi4: spi4grp &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10 <span class="number">0x70a1</span></span><br><span class="line">MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11 <span class="number">0x70a1</span></span><br><span class="line"><span class="comment">/*MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 0x70a1</span></span><br><span class="line"><span class="comment">MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 0x80000000*/</span></span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spi4 &#123;</span><br><span class="line">    compatible = <span class="string">"spi-gpio"</span>;</span><br><span class="line">    pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_spi4&gt;;</span><br><span class="line">    <span class="comment">/* pinctrl-assert-gpios = &lt;&amp;gpio5 8 GPIO_ACTIVE_LOW&gt;; */</span></span><br><span class="line">    status = <span class="string">"okay"</span>;</span><br><span class="line">    gpio-sck = &lt;&amp;gpio5 <span class="number">11</span> <span class="number">0</span>&gt;;</span><br><span class="line">    gpio-mosi = &lt;&amp;gpio5 <span class="number">10</span> <span class="number">0</span>&gt;;</span><br><span class="line">    <span class="comment">/* cs-gpios = &lt;&amp;gpio5 7 0&gt;; */</span></span><br><span class="line">    num-chipselects = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">    <span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line">    <span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line"></span><br><span class="line">    gpio_spi: gpio_spi@<span class="number">0</span> &#123;</span><br><span class="line">        compatible = <span class="string">"fairchild,74hc595"</span>;</span><br><span class="line">        gpio-controller;</span><br><span class="line">        <span class="meta">#gpio-cells = <span class="meta-string">&lt;2&gt;;</span></span></span><br><span class="line">        reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">        registers-number = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">        registers-<span class="keyword">default</span> = /bits/ <span class="number">8</span> &lt;<span class="number">0x57</span>&gt;;</span><br><span class="line">        spi-<span class="built_in">max</span>-frequency = &lt;<span class="number">100000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_enet1: enet1grp &#123;</span><br><span class="line">    fsl,pins = &lt;</span><br><span class="line">        MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1<span class="number">0x4001b031</span></span><br><span class="line">        MX6UL_PAD_SNVS_TAMPER7__GPIO5_IO07 <span class="number">0x10b0</span><span class="comment">/* ENET1_RESET */</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pinctrl_enet2: enet2grp &#123;</span><br><span class="line">    fsl,pins = &lt;</span><br><span class="line">        MX6UL_PAD_GPIO1_IO07__ENET2_MDC<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_GPIO1_IO06__ENET2_MDIO<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01<span class="number">0x1b0b0</span></span><br><span class="line">        MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2<span class="number">0x4001b031</span></span><br><span class="line">        MX6UL_PAD_SNVS_TAMPER8__GPIO5_IO08 <span class="number">0x10b0</span><span class="comment">/* ENET2_RESET */</span></span><br><span class="line">        &gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&amp;fec1 &#123;</span><br><span class="line">pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet1&gt;;</span><br><span class="line">phy-mode = <span class="string">"rmii"</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy0&gt;;</span><br><span class="line">phy-reset-gpios = &lt;&amp;gpio5 <span class="number">7</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line">status = <span class="string">"okay"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;fec2 &#123;</span><br><span class="line">pinctrl-names = <span class="string">"default"</span>;</span><br><span class="line">pinctrl<span class="number">-0</span> = &lt;&amp;pinctrl_enet2&gt;;</span><br><span class="line">phy-mode = <span class="string">"rmii"</span>;</span><br><span class="line">phy-handle = &lt;&amp;ethphy1&gt;;</span><br><span class="line">phy-reset-gpios = &lt;&amp;gpio5 <span class="number">8</span> GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">phy-reset-duration = &lt;<span class="number">200</span>&gt;;</span><br><span class="line">status = <span class="string">"okay"</span>;</span><br><span class="line"></span><br><span class="line">mdio &#123;</span><br><span class="line"><span class="meta">#address-cells = <span class="meta-string">&lt;1&gt;;</span></span></span><br><span class="line"><span class="meta">#size-cells = <span class="meta-string">&lt;0&gt;;</span></span></span><br><span class="line"></span><br><span class="line">ethphy0: ethernet-phy@<span class="number">0</span> &#123;</span><br><span class="line">compatible = <span class="string">"ethernet-phy-ieee802.3-c22"</span>;</span><br><span class="line">reg = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ethphy1: ethernet-phy@<span class="number">1</span> &#123;</span><br><span class="line">compatible = <span class="string">"ethernet-phy-ieee802.3-c22"</span>;</span><br><span class="line">reg = &lt;<span class="number">1</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改<code>drivers/net/ethernet/freescale/fec_main.c</code>中的<code>fec_probe</code>函数，添加如下代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置 MX6UL_PAD_ENET1_TX_CLK 和 MX6UL_PAD_ENET2_TX_CLK</span></span><br><span class="line"><span class="comment">* 这两个 IO 的复用寄存器的 SION 位为 1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> __iomem *IMX6U_ENET1_TX_CLK;</span><br><span class="line"><span class="keyword">void</span> __iomem *IMX6U_ENET2_TX_CLK;</span><br><span class="line"></span><br><span class="line">IMX6U_ENET1_TX_CLK = ioremap(<span class="number">0X020E00DC</span>, <span class="number">4</span>);</span><br><span class="line">writel(<span class="number">0X14</span>, IMX6U_ENET1_TX_CLK);</span><br><span class="line"></span><br><span class="line">IMX6U_ENET2_TX_CLK = ioremap(<span class="number">0X020E00FC</span>, <span class="number">4</span>);</span><br><span class="line">writel(<span class="number">0X14</span>, IMX6U_ENET2_TX_CLK);</span><br></pre></td></tr></table></figure><p>然后编译下设备树文件，并且在图形化界面中使能<code>LAN8720A</code>的驱动。</p><blockquote><ol><li><p>Device Drivers</p></li><li><p>Network device support</p></li><li><p>PHY Device support and infrastructure</p></li><li><p>Drivers for SMSC PHYs</p></li></ol></blockquote><p>最后编译下Linux的内核文件。</p><p>然后使用如下命令加载Linux镜像到内存中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatload mmc <span class="number">0</span>:<span class="number">1</span> <span class="number">80800000</span> zimage </span><br><span class="line">fatload mmc <span class="number">0</span>:<span class="number">1</span> <span class="number">83000000</span> imx6ull<span class="number">-14</span>x14-myboard.dts </span><br><span class="line">bootz <span class="number">80800000</span> - <span class="number">83000000</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL裸机开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL学习笔记(五)</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94.html</id>
    <published>2020-09-18T15:08:01.000Z</published>
    <updated>2020-12-18T15:14:52.207Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL裸机开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="1-移植NXP官方-uboot-到-alpha-开发板"><a href="#1-移植NXP官方-uboot-到-alpha-开发板" class="headerlink" title="1. 移植NXP官方 uboot 到 alpha 开发板"></a>1. 移植NXP官方 uboot 到 alpha 开发板</h2><ol><li><p>添加板子默认配置文件</p><p>借鉴NXP官方6ull evk 开发板，修改NXP官方6ull evk开发板配置文件<code>configs/mx6ull_14x14_evk_emmc_defconfig</code>并重命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SYS_EXTRA_OPTIONS&#x3D;&quot;IMX_CONFIG&#x3D;board&#x2F;freescale&#x2F;mx6ull_myboard_emmc&#x2F;imximage.cfg,MX6ULL_EVK_EMMC_REWORK&quot;</span><br><span class="line">CONFIG_ARM&#x3D;y</span><br><span class="line">CONFIG_ARCH_MX6&#x3D;y</span><br><span class="line">CONFIG_TARGET_MX6ULL_MYBOARD_EMMC&#x3D;y</span><br><span class="line">CONFIG_CMD_GPIO&#x3D;y</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>添加板子对应的头文件</p><p>不同的板子，有一些需要配置的信息，一般是在一个头文件里配置，每个板子有一个。对于NXP官方的6ULL EVK板子，头文件是<code>include/configs/mx6ullevk.h</code>，复制该文件为<code>mx6ull_myboard_emmc.h</code>，然后修改<code>mx6ull_myboard_emmc.h</code>该文件内的条件编译为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __MX6ULL_MYBOARD_EMMC_CONFIG_H</span><br><span class="line">#define __MX6ULL_MYBOARD_EMMC_CONFIG_H</span><br></pre></td></tr></table></figure></li><li><p>添加板子对应的板级文件夹</p><p>每个板子都有特有的文件，也叫板级文件。这里我们将6ULL EVK的板级文件夹<code>board/freescale/mx6ullevk</code>直接拷贝一份，并重命名为<code>mx6ull_myboard_emmc</code> 。修改<code>mx6ull_myboard_emmc</code>文件夹中的<code>mx6ullevk.c</code> <code>Makefile</code> <code>imximage.cfg</code> <code>Kconfig</code> <code>MAINTAINERS</code>文件。 最后需要修改<code>arch/arm/cpu/armv7/mx6/Kconfig</code>文件，添加以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config TARGET_MX6ULL_MYBOARD_EMMC</span><br><span class="line">bool &quot;Support mx6ull_myboard_emmc&quot;</span><br><span class="line">select MX6ULL</span><br><span class="line">select DM</span><br><span class="line">select DM_THERMAL</span><br><span class="line"></span><br><span class="line">source &quot;board&#x2F;freescale&#x2F;mx6ull_myboard_emmc&#x2F;Kconfig&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改uboot图形配置界面</p></li><li><p>LCD驱动修改</p><p>修改<code>board/mx6ull_myboard_emmc/mx6ull_myboard_emmc.c</code> <code>include/configs/mx6ull_myboard_emmc.h</code> 文件来修改驱动。</p><ul><li>确认LCD IO 初始化正确，修改<code>mx6ull_myboard_emmc.c</code>中的LCD_PADS</li><li>修改LCD 参数，<code>mx6ull_myboard_emmc.c</code>中的displays。fb_videomode表示RGB LCD参数。</li><li>修改<code>mx6ull_myboard_emmc.h</code>的环境变量panel=TFT43AB 为<code>mx6ull_myboard_emmc.c</code>中<code>display_info_t const displays[]</code>中的<code>name</code>值。</li></ul></li><li><p>网络驱动修改</p><p>LAN8720有一个管理接口，叫做MDIO，有两根线 <code>MDIO</code>、<code>MDC</code>，一个MDIO接口可以管理32个PHY芯片。MDIO通过<code>PHY ADDR</code>来确定访问哪个PHY芯片。ALPHA开发板的<code>ENET1</code>的<code>PHY ADDR</code>是<code>0x0</code>, <code>ENET2</code>的PHY ADDR是<code>0x1</code>；每个LAN8720都有一个复位引脚，ENET1是<code>SNVS_TAMPER8</code>。</p><p>LAN8720驱动，因为所有的PHY芯片的前16个寄存器一模一样，因此uboot里面已经写好了通用PHY驱动，所以理论上不需要修改。</p></li></ol><ul><li>修改<code>mx6ull_myboard_emmc.h</code>文件中的<code>PHY ADDR</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (CONFIG_FEC_ENET_DEV == 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMX_FEC_BASEENET_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_MXC_PHYADDR          0x0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_XCV_TYPE             RMII</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (CONFIG_FEC_ENET_DEV == 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMX_FEC_BASEENET2_BASE_ADDR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_MXC_PHYADDR0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_FEC_XCV_TYPERMII</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>删除原有的74LV595的驱动代码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOX_SDI IMX_GPIO_NR(5, 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOX_STCP IMX_GPIO_NR(5, 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOX_SHCP IMX_GPIO_NR(5, 11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOX_OE IMX_GPIO_NR(5, 8)</span></span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENET1_RESET IMX_GPIO_NR(5, 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENET2_RESET IMX_GPIO_NR(5, 8)</span></span><br></pre></td></tr></table></figure><p>然后删除和74LV595有关的代码，添加ALPHA开发板驱动代码。</p><p>分别在<code>mx6ull_myboard_emmc.c</code>中的<code>fec1_pads[]</code> 和<code>fec2_pads[]</code>中添加以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fec1_pads[]</span></span><br><span class="line">MX6_PAD_SNVS_TAMPER7__GPIO5_IO07 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br><span class="line"></span><br><span class="line"><span class="comment">//fec2_pads[]</span></span><br><span class="line">MX6_PAD_SNVS_TAMPER8__GPIO5_IO08 | MUX_PAD_CTRL(NO_PAD_CTRL),</span><br></pre></td></tr></table></figure><p>修改<code>setup_iomux_fec(int fec_id)</code>函数为以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setup_iomux_fec</span><span class="params">(<span class="keyword">int</span> fec_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fec_id == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));</span><br><span class="line"><span class="comment">// 添加ENET1_RESET复位代码</span></span><br><span class="line">gpio_direction_output(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET1_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));</span><br><span class="line"><span class="comment">// 添加ENET2_RESET复位代码</span></span><br><span class="line">gpio_direction_output(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">0</span>);</span><br><span class="line">mdelay(<span class="number">20</span>);</span><br><span class="line">gpio_set_value(ENET2_RESET, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>int genphy_update_link(struct phy_device *phydev)</code>中的最上面添加以下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PHY_SMSC<span class="comment">// CONFIG_PHY_SMSC 需要在 mx6ull_myboard_emmc.h 中定义</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> lan8720_flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bmcr_reg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (lan8720_flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);</span><br><span class="line"><span class="keyword">while</span> (phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) &amp; <span class="number">0X8000</span>)</span><br><span class="line">&#123;</span><br><span class="line">udelay(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);</span><br><span class="line">lan8720_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="2-Uboot命令"><a href="#2-Uboot命令" class="headerlink" title="2. Uboot命令"></a>2. Uboot命令</h2><table><thead><tr><th>命令</th><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>md</td><td>md[.b, .w, .l] address [# of objects]</td><td>用于显示内存值</td></tr><tr><td>nm</td><td>nm [.b, .w, .l] address</td><td>用于修改指定地址的值，q退出</td></tr><tr><td>mm</td><td>mm [.b, .w, .l] address</td><td>如上，地址会自增</td></tr><tr><td>cp</td><td>cp [.b, .w, .l] source target count</td><td>数据拷贝命令，用于将 DRAM 中的数据从一段内存拷贝到另一段内存中，或者把 Nor Flash 中的数据拷贝到 DRAM 中</td></tr><tr><td>mmc</td><td>mmc 是一系列的命令。？mmc 查询</td><td>uboot 支持 EMMC 和 SD 卡，因此也要提供 EMMC 和 SD 卡的操作命令。一般认为 EMMC 和 SD 卡是同一个东西。</td></tr><tr><td>fatinfo</td><td>fatinfo &lt;interface&gt; [&lt;dev[:part]&gt;]</td><td>查询指定 MMC 设置指定分区的文件系统信息,例如<code>fatinfo mmc 1:1</code></td></tr><tr><td>fatls</td><td>fatls &lt;interface&gt; [&lt;dev[:part]&gt;] [directory]</td><td>用于查询 FAT 格式设备的目录和文件信息，如<code>fatls mmc 1:1</code>，查询 EMMC 分区 1 中的所有的目录和文件。</td></tr><tr><td>fstype</td><td>fstype &lt;interface&gt; &lt;dev&gt;:&lt;part&gt;</td><td>查看 MMC 设备某个分区的文件系统格式，如<code>fstype mmc 1:0</code></td></tr><tr><td>fatload</td><td>fatload &lt;interface&gt; [&lt;dev[:part]&gt; [&lt;addr&gt; [&lt;filename&gt; [bytes [pos]]]]]</td><td>用于将指定的文件读取到 DRAM 中，如<code>fatload mmc 1:1 80800000 zImage</code></td></tr><tr><td>bootz</td><td>bootz [addr [initrd[:size]] [fdt]]</td><td>引导[启动]Linux(zImage)，如<code>bootz 80800000 – 83000000</code>，80800000存放着Linux内核，83000000是设备树，不使用initrd时，使用－代替</td></tr><tr><td>go</td><td>go addr [arg …]</td><td>用于跳到指定的地址处执行应用，如<code>tftp 87800000 printf.bin</code> <code>go 87800000</code></td></tr></tbody></table><h2 id="3-Uboot-图形化配置方法"><a href="#3-Uboot-图形化配置方法" class="headerlink" title="3. Uboot 图形化配置方法"></a>3. Uboot 图形化配置方法</h2><ol><li><p>通过终端配置</p></li><li><p>首先进入到uboot的源码路径下</p></li><li><p>然后使用默认配置 <code>make mx6ull_myboard_emmc_defconfig</code> 进行默认配置</p></li><li><p>输入<code>make menuconfig</code> 打开图形化界面。<strong>注意：</strong>如果出现错误，需要安装<code>ncurses</code>库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br><span class="line">sudo apt install libncurses5</span><br><span class="line">sudo apt install libncurses5-dev</span><br></pre></td></tr></table></figure></li><li><p>图形化配置界面对于一个功能的编译或者叫做选择有三种模式。</p><ul><li>Y：对应的功能编译到uboot里面。</li><li>N：对应的功能不编译到uboot里面。</li><li>M：将对应的功能编译成模块，linux内常用，uboot不支持。</li></ul></li><li><p>当我们配置好后，因为只是写入到<code>.config</code>文件中，清理工程后会丢失，因此需要保存自己的配置文件。在图形配置界面，选择<code>save</code>选项来保存，使用<code>load</code>选项来加载配置文件。</p></li></ol>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL裸机开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL学习笔记(四)</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B.html</id>
    <published>2020-09-18T15:00:50.000Z</published>
    <updated>2020-12-18T15:12:53.284Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL裸机开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。推荐看《跟我一起写Makefile》</p><h2 id="Makefile中变量的使用"><a href="#Makefile中变量的使用" class="headerlink" title="Makefile中变量的使用"></a>Makefile中变量的使用</h2><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上”<code>$</code>“符号，但最好<br>用小括号“<code>（）</code>”或是大括号“<code>{}</code>”把变量给包括起来。如果你要使用真实的“<code>$</code>”字符，<br>那么你需要用“<code>$$</code>”来表示。</p><a id="more"></a><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符:="></a>操作符<code>:=</code></h3><p>为了防止“<code>=</code>”在变量中使用变量会造成无限的变量展开，比如下面这种情况</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = $&#123;B&#125;</span><br><span class="line">B = $&#123;A&#125;</span><br></pre></td></tr></table></figure><p>所以常用<code>:=</code>操作符来定义变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $&#123;x&#125; bar</span><br><span class="line">x := later</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure><p>这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变<br>量。 比如</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := $&#123;x&#125; bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure><p>那么<code>y</code>的值是<code>bar</code>，而不是<code>foo bar</code></p><h3 id="操作符-1"><a href="#操作符-1" class="headerlink" title="操作符?="></a>操作符<code>?=</code></h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure><p>其含义是，如果<code>FOO</code>没有被定义过，那么变量<code>FOO</code>的值就是<code>bar</code>，否则，这条语句什么也不做，相当于</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><h2 id="Makefile练手"><a href="#Makefile练手" class="headerlink" title="Makefile练手"></a>Makefile练手</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的交叉编译器</span></span><br><span class="line">CROSS_COMPILER ?= arm-linux-gnueabihf-</span><br><span class="line">CC := <span class="variable">$(CROSS_COMPILER)</span>gcc</span><br><span class="line">LD := <span class="variable">$(CROSS_COMPILER)</span>ld</span><br><span class="line">OBJCOPY := <span class="variable">$(CROSS_COMPILER)</span>objcopy</span><br><span class="line">OBJDUMP := <span class="variable">$(CROSS_COMPILER)</span>objdump</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接生成的文件名</span></span><br><span class="line">TARGET := led</span><br><span class="line"></span><br><span class="line"><span class="comment"># Make查找路径</span></span><br><span class="line">VPATH :=project \</span><br><span class="line">imx6ul \</span><br><span class="line">bsp/led \</span><br><span class="line">bsp/clk \</span><br><span class="line">bsp/delay \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工程所有.C .S .H 文件所在路径</span></span><br><span class="line">INCLUDEDIRS := project \</span><br><span class="line">imx6ul \</span><br><span class="line">bsp/led \</span><br><span class="line">bsp/clk \</span><br><span class="line">bsp/delay \</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给路径加上 -I 参数，因为编译时需要对路径需要使用 -I 选项</span></span><br><span class="line">INCLUDES :=<span class="variable">$(<span class="built_in">patsubst</span> %, -I %, <span class="variable">$(INCLUDEDIRS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找工程下所有的 .s .c 文件，包含路径</span></span><br><span class="line">SFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(INCLUDEDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.s)</span>)</span><br><span class="line">CFILES := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>, <span class="variable">$(INCLUDEDIRS)</span>, $(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有的 .s .c 文件 去掉前面的路径</span></span><br><span class="line">SFILESNODIR:= <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(SFILES)</span>)</span></span><br><span class="line">CFILESNODIR:= <span class="variable">$(<span class="built_in">notdir</span> <span class="variable">$(CFILES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有的 .s .c 文件的文件名，将其后缀名改为 .o ,并添加 obj/ 前缀,这样编译生成的.o文件就会放置到 obj文件夹下</span></span><br><span class="line">SOBJS:= <span class="variable">$(<span class="built_in">addprefix</span> obj/, $(SFILESNODIR:.s=.o)</span>)</span><br><span class="line">COBJS:= <span class="variable">$(<span class="built_in">addprefix</span> obj/, $(CFILESNODIR:.c=.o)</span>)</span><br><span class="line"></span><br><span class="line">OBJS :=  <span class="variable">$(SOBJS)</span> <span class="variable">$(COBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>.bin:<span class="variable">$(OBJS)</span></span><br><span class="line"><span class="variable">$(LD)</span> -T imx6ul.lds -o <span class="variable">$(TARGET)</span>.elf <span class="variable">$^</span></span><br><span class="line"><span class="variable">$(OBJCOPY)</span> -O binary -S -g <span class="variable">$(TARGET)</span>.elf <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(OBJDUMP)</span> -D -m arm <span class="variable">$(TARGET)</span>.elf &gt; <span class="variable">$(TARGET)</span>.dis</span><br><span class="line"></span><br><span class="line"><span class="comment"># SOBJS中所有匹配 obj/%.o 的文件名 所对应的依赖 %.s</span></span><br><span class="line"><span class="variable">$(SOBJS)</span> : obj/%.o : %.s</span><br><span class="line"><span class="variable">$(CC)</span> -c -O2 <span class="variable">$(INCLUDES)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># COBJS中所有匹配 obj/%.o 的文件名 所对应的依赖 %.c</span></span><br><span class="line"><span class="variable">$(COBJS)</span> : obj/%.o : %.c</span><br><span class="line"><span class="variable">$(CC)</span> -c -O2 <span class="variable">$(INCLUDES)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf obj/*.o <span class="variable">$(TARGET)</span>.bin <span class="variable">$(TARGET)</span>.elf <span class="variable">$(TARGET)</span>.dis load.imx</span><br><span class="line"></span><br><span class="line">.PHONY : printf</span><br><span class="line"><span class="section">printf:</span></span><br><span class="line">@echo INCLUDES=<span class="variable">$(INCLUDES)</span></span><br><span class="line">@echo SFILES=<span class="variable">$(SFILES)</span></span><br><span class="line">@echo CFILES=<span class="variable">$(CFILES)</span></span><br><span class="line">@echo SFILESNODIR=<span class="variable">$(SFILESNODIR)</span></span><br><span class="line">@echo CFILESNODIR=<span class="variable">$(CFILESNODIR)</span></span><br><span class="line">@echo SOBJS=<span class="variable">$(SOBJS)</span></span><br><span class="line">@echo COBJS=<span class="variable">$(COBJS)</span></span><br><span class="line">@echo OBJS=<span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL裸机开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL学习笔记(三)</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89.html</id>
    <published>2020-09-18T14:58:51.000Z</published>
    <updated>2020-12-18T15:12:39.603Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL裸机开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="链接脚本"><a href="#链接脚本" class="headerlink" title="链接脚本"></a>链接脚本</h2><p>链接脚本的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">. &#x3D; 0X87800000;</span><br><span class="line">.text :</span><br><span class="line">&#123;</span><br><span class="line">start.o</span><br><span class="line">main.o</span><br><span class="line">*(.text)</span><br><span class="line">&#125;</span><br><span class="line">.rodata ALIGN(4) : &#123;*(.rodata)&#125;</span><br><span class="line">.data ALIGN(4) : &#123;*(.data)&#125;</span><br><span class="line">__bss_start &#x3D; .;</span><br><span class="line">.bss ALIGN(4) : &#123;*(.bss) *(.COMMON)&#125;</span><br><span class="line">__bss_end &#x3D; .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="加上清除BSS段，代码不运行"><a href="#加上清除BSS段，代码不运行" class="headerlink" title="加上清除BSS段，代码不运行"></a>加上清除BSS段，代码不运行</h2><p>__bss_start = 0X87800289 。对于32位的SOC来说，一般访问是4字节访问的。0X0，0X4，0X8，0XC。芯片处理的时候以4字节访问，因此会从0X87800288开始清除BSS段。然而0X87800288不属于BSS段。所以我们需要对__bss_start进行四字节对齐。按照四字节对齐的原理，__bss_start = 0X8780028C。所以需要设置__bss_start为四字节对齐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS </span><br><span class="line">&#123;</span><br><span class="line">    . &#x3D; 0x87800000;</span><br><span class="line">    .text : </span><br><span class="line">    &#123;</span><br><span class="line">        obj&#x2F;start.o;</span><br><span class="line">        *(.text);</span><br><span class="line">    &#125;</span><br><span class="line">    .rodata ALIGN(4) : &#123;*(.rodata)&#125;</span><br><span class="line">    .data ALIGN(4) : &#123;*(.data)&#125;</span><br><span class="line">    . &#x3D; ALIGN(4);</span><br><span class="line">    __bss_start &#x3D; .;</span><br><span class="line">    .bss ALIGN(4) : &#123;*(.bss) *(COMMON)&#125;</span><br><span class="line">    __bss_end &#x3D; .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL裸机开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>IMX6ULL学习笔记(二)</title>
    <link href="https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C.html"/>
    <id>https://proudrabbit.gitee.io/IMX6ULL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C.html</id>
    <published>2020-09-18T14:50:13.000Z</published>
    <updated>2020-12-18T15:04:59.442Z</updated>
    
    <content type="html"><![CDATA[<p><strong>IMX6ULL裸机开发学习</strong></p><p>以下内容是我在学习正点原子<code>IMX6ULL</code>开发板<code>alpha</code>中记录的笔记，部分摘录自正点原子<code>IMX6ULL开发手册</code>。</p><h2 id="C语言运行环境构建"><a href="#C语言运行环境构建" class="headerlink" title="C语言运行环境构建"></a>C语言运行环境构建</h2><ol><li><p>设置处理器模式</p><p>设置6ULL处于SVC模式下，设置CPSR寄存器的bit4-0，就是M[4:0]为10011=0X13，读写状态寄存器需要用MRS和MSR指令，</p></li></ol><a id="more"></a><ol start="2"><li><p>设置sp指针</p><p><code>sp</code>可以指向内部RAM，也可以指向DDR，我们将其指向DDR。512MB的范围 0X80000000～0X9FFFFFFF。栈大小设置为 0X200000=2MB。处理器栈增长模式，A7是向下增长的。设置SP=0X80200000</p></li><li><p>跳转到C语言</p><p>使用b指令，跳转到C语言函数，比如跳转到main函数。</p></li></ol><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.global _start&#x2F;* 全局标号 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 描述： _start函数，程序从此函数开始执行，主要是完成C语言运行环境设置</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">_start:</span><br><span class="line">@ 设置处理器进入SVC模式</span><br><span class="line">mrs r0, cpsr</span><br><span class="line">bic r0, r0, #0x1f@ 将r0的低五位清零，也就是M[4:0]</span><br><span class="line">orr r0, r0, #0x13@ r0或上0x13 表示使用SVC模式</span><br><span class="line">msr cpsr, r0@ 将r0中的数据写入到cpsr寄存器中</span><br><span class="line"></span><br><span class="line">ldr sp, &#x3D;0x80200000@ 设置栈指针</span><br><span class="line">b main@ 跳转到main函数运行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      正点原子alpha开发板IMX6ULL裸机开发学习笔记。
    
    </summary>
    
    
    
      <category term="嵌入式" scheme="https://proudrabbit.gitee.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
      <category term="IMX6ULL" scheme="https://proudrabbit.gitee.io/tags/IMX6ULL/"/>
    
      <category term="学习笔记" scheme="https://proudrabbit.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
